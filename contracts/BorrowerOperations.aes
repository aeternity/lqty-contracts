@compiler >= 6

include "Option.aes"
include "./dependencies/SafeMath.aes"
include "./interfaces/IBorrowerOperations.aes"
include "./interfaces/ITroveManager.aes"
include "./interfaces/IStabilityPool.aes"
include "./interfaces/IDefaultPool.aes"
include "./dependencies/Utils.aes"
include "./interfaces/ICollSurplusPool.aes"
include "./interfaces/IPriceFeed.aes"
include "./interfaces/ISortedTroves.aes"
include "./interfaces/IAEUSDToken.aes"
include "./interfaces/ILQTYStaking.aes"
include "./dependencies/LiquityMath.aes"
include "./dependencies/Utils.aes"

contract BorrowerOperations =

    //------------------------------------------------------------------------------
    // DATA & STATE
    //------------------------------------------------------------------------------

    record state = {
          owner: option(address)
        , addresses: option(addresses)
        }

    record addresses = {
          borrower_operations: IBorrowerOperations
        , trove_manager: ITroveManager
        , stability_pool: IStabilityPool
        , default_pool: IDefaultPool
        , coll_surplus_pool: ICollSurplusPool
        , lqty_staking: ILQTYStaking
        , aeusd_token: IAEUSDToken
        , sorted_troves: ISortedTroves
        , active_pool: IActivePool
        , price_feed: IPriceFeed
        , gas_pool: address
        }


    // A doubly linked list of Troves, sorted by their collateral ratios

    record adjust_trove = {
          price: int
        , is_coll_increase: bool
        , coll_change: int
        , net_debt_change: int
        , debt: int
        , coll: int
        , old_icr: int
        , new_icr: int
        , new_tcr: int
        , aeusd_fee: int
        , new_debt: int
        , new_coll: int
        , stake: int
        }

    record open_trove = {
          price: int
        , aeusd_fee: int
        , net_debt: int
        , composite_debt: int
        , icr: int
        , nicr: int
        , stake: int
        , array_index: int
        }

    record contracts_cache = {
          trove_manager: ITroveManager
        , active_pool: IActivePool
        , aeusd_token: IAEUSDToken
        }

    //NOTE: we are declaring it here because pattern matching
    //doesn't play well with sum types declared in interfaces
    datatype borrower_operation = OpenTrove | CloseTrove | AdjustTrove

    function
        borrower_operation_to_str: borrower_operation => string
        borrower_operation_to_str(OpenTrove) = "open"
        borrower_operation_to_str(CloseTrove) = "close"
        borrower_operation_to_str(AdjustTrove) = "adjust"

    //------------------------------------------------------------------------------
    // ENTRYPOINTS
    //------------------------------------------------------------------------------

    entrypoint init()=
        Chain.event( OwnershipTransferred(Utils.zero_address(),Call.caller) )
        {  owner = Some(Call.caller)
         , addresses = None
         }

    stateful entrypoint set_addresses(addresses: addresses) =
        //requirement
        only_owner()

        put( state { addresses = Some(addresses) })

        Chain.event(TroveManagerAddressChanged(addresses.trove_manager))
        Chain.event(ActivePoolAddressChanged(addresses.active_pool))
        Chain.event(DefaultPoolAddressChanged(addresses.default_pool))
        Chain.event(StabilityPoolAddressChanged(addresses.stability_pool))
        Chain.event(CollSurplusPoolAddressChanged(addresses.coll_surplus_pool))
        Chain.event(PriceFeedAddressChanged(addresses.price_feed))
        Chain.event(SortedTrovesAddressChanged(addresses.sorted_troves))
        Chain.event(AEUSDTokenAddressChanged(addresses.aeusd_token))
        Chain.event(LQTYStakingAddressChanged(addresses.lqty_staking))
        Chain.event(GasPoolAddressChanged(addresses.gas_pool))

        renounce_ownership()


    //------------------------------------------------------------------------------
    // BORROWER TROVE OPERATIONS
    //------------------------------------------------------------------------------

    payable stateful entrypoint open_trove(
          max_fee_percentage: int
        , aeusd_amount: int
        , upper_hint: address
        , lower_hint: address
        ): open_trove = withAddresses( (addresses) =>
            /*let contracts_cache: contracts_cache = {*/
                      /*trove_manager = addresses.trove_manager*/
                    /*, active_pool = addresses.active_pool*/
                    /*, aeusd_token = addresses.aeusd_token*/
                    /*}*/
            let vars: open_trove = {
                      price = addresses.price_feed.fetch_price()
                    , aeusd_fee = 0
                    , net_debt = aeusd_amount
                    , composite_debt = 0
                    , icr = 0
                    , nicr = 0
                    , stake = 0
                    , array_index = 0
                    }

            let is_recovery_mode: bool = check_recovery_mode(vars.price)

            require_valid_max_fee_percentage(max_fee_percentage, is_recovery_mode)
            require_troveis_not_active(addresses.trove_manager, Call.caller)

            /*vars.AEUSDFee*/ //TODO: i don't know what exactly this supposed to do

            let vars = if (is_recovery_mode) vars {
                              aeusd_fee = trigger_borrowing_fee(aeusd_amount, max_fee_percentage)
                            , net_debt @ p = SafeMath.add(p,vars.aeusd_fee)
                            }
                       else vars

            require_at_least_min_net_debt(vars.net_debt)

            // ICR is based on the composite debt, i.e. the requested AEUSD amount + AEUSD borrowing fee + AEUSD gas comp.
            let vars = vars { composite_debt = get_composite_debt(vars.net_debt) }
            require(vars.composite_debt > 0, "BorrowerOps: composite_debt should be greater then 0")

            let vars = vars {  icr = LiquityMath.compute_cr(Call.value, vars.composite_debt, vars.price)
                             , nicr = LiquityMath.compute_nominal_cr(Call.value, vars.composite_debt)
                             }
            if (is_recovery_mode)
                require_icr_is_above_ccr(vars.icr)
            else
                require_icr_is_above_mcr(vars.icr)
                // bools: coll increase, debt increase
                let new_tcr = get_new_tcr_from_trove_change( Call.value, true, vars.composite_debt, true, vars.price)
                require_new_tcr_is_above_ccr(new_tcr)

            // Set the trove struct's properties
            addresses.trove_manager.set_trove_status(Call.caller, 1)
            addresses.trove_manager.increase_trove_coll(Call.caller, Call.value)
            addresses.trove_manager.increase_trove_debt(Call.caller, vars.composite_debt)

            addresses.trove_manager.update_trove_reward_snapshots(Call.caller)
            let vars = vars { stake = addresses.trove_manager.update_stake_and_total_stakes(Call.caller) }

            addresses.sorted_troves.insert(Call.caller, vars.nicr, upper_hint, lower_hint)
            let vars = vars { array_index = addresses.trove_manager.add_trove_owner_to_array(Call.caller) }
            Chain.event( TroveCreated(Call.caller, vars.array_index) )

            // Move the ae to the Active Pool, and mint the aeusd_amount to the borrower
            addresses.active_pool.receive_ae(value=Call.value)
            withdraw_aeusd(addresses.active_pool, addresses.aeusd_token, Call.caller, aeusd_amount, vars.net_debt)
            // Move the AEUSD gas compensation to the Gas Pool
            let gas_compensation = aeusd_gas_compensation()
            withdraw_aeusd(addresses.active_pool, addresses.aeusd_token, addresses.gas_pool, gas_compensation, gas_compensation)

            Chain.event( TroveUpdated(Call.caller, Utils.xsToPayload'(
                    [vars.composite_debt,Call.value,vars.stake],
                    borrower_operation_to_str(OpenTrove)
                )))
            Chain.event(AEUSDBorrowingFeePaid(Call.caller, vars.aeusd_fee))
            vars
        )


    //------------------------------------------------------------------------------
    // HELPER FUNCTIONS
    //------------------------------------------------------------------------------

    // Issue the specified amount of AEUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a AEUSDFee)
    function withdraw_aeusd(
          active_pool: IActivePool
        , aeusd_token: IAEUSDToken
        , account: address
        , aeusd_amount: int
        , net_debt_increase: int ) =
        active_pool.increase_aeusd_debt(net_debt_increase)
        aeusd_token.mint(account, aeusd_amount)

    function trigger_borrowing_fee( aeusd_amount: int , max_fee_percentage: int ): int =
        withAddresses( (addresses) =>
            addresses.trove_manager.decay_base_rate_from_borrowing() // decay the baseRate state variable
            let aeusd_fee = addresses.trove_manager.get_borrowing_fee(aeusd_amount)

            require_user_accepts_fee(aeusd_fee, aeusd_amount, max_fee_percentage)

            // Send fee to LQTY staking contract
            addresses.lqty_staking.increase_f_aeusd(aeusd_fee)
            addresses.aeusd_token.mint(addresses.lqty_staking.address, aeusd_fee)
            aeusd_fee )


    //------------------------------------------------------------------------------
    // CONSTRAINT FUNCTIONS
    //------------------------------------------------------------------------------

    function require_valid_max_fee_percentage(max_fee_percentage: int , is_recovery_mode: bool) =
        if (is_recovery_mode)
            require(
                max_fee_percentage =< Utils.decimal_precision(),
                "Max fee percentage must less than or equal to 100%")
        else
            require(max_fee_percentage >= borrowing_fee_floor() && max_fee_percentage =< Utils.decimal_precision(),
                "Max fee percentage must be between 0.5% and 100%")

    function require_singular_coll_change(coll_withdrawal: int) =
        require(Call.value == 0 || coll_withdrawal == 0, "BorrowerOperations: Cannot withdraw and add coll")

    function require_caller_is_borrower(borrower: address) =
        require(Call.caller == borrower, "BorrowerOps: Caller must be the borrower for a withdrawal")

    function require_non_zero_adjustment(coll_withdrawal: int, aeusd_change: int) =
        require(Call.value != 0 || coll_withdrawal != 0 || aeusd_change != 0,
            "BorrowerOps: There must be either a collateral change or a debt change")

    function require_troveis_active(trove_manager: ITroveManager, borrower: address) =
        require(trove_manager.get_trove_status(borrower) == 1,
            "BorrowerOps: Trove does not exist or is c losed")

    function require_troveis_not_active(trove_manager: ITroveManager,borrower: address) =
        require(trove_manager.get_trove_status(borrower) != 1, "BorrowerOps: Trove is active")

    function require_non_zero_debt_change(aeusd_change: int) =
        require(aeusd_change > 0, "BorrowerOps: Debt increase requires non-zero debtChange")

    function require_not_in_recovery_mode(price: int) =
        require(check_recovery_mode(price), "BorrowerOps: Operation not permitted during Recovery Mode")

    function require_no_coll_withdrawal(coll_withdrawal: int) =
        require(coll_withdrawal == 0, "BorrowerOps: Collateral withdrawal not permitted Recovery Mode")

    //WARN: this modifies the vars, should be replaced after calling it
    function require_valid_adjustment_in_current_mode (
          is_recovery_mode: bool
        , coll_withdrawal: int
        , is_debt_increase: bool
        , vars: adjust_trove ): adjust_trove =
        /*
        *In Recovery Mode, only allow:
        *
        * - Pure collateral top-up
        * - Pure debt repayment
        * - Collateral top-up with debt repayment
        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR
            (and by extension improves the TCR).
        *
        * In Normal Mode, ensure:
        *
        * - The new ICR is above MCR
        * - The adjustment won't pull the TCR below CCR
        */
        if (is_recovery_mode)
            require_no_coll_withdrawal(coll_withdrawal)
            if (is_debt_increase)
                require_icr_is_above_ccr(vars.new_icr)
                require_new_icr_is_above_old_icr(vars.new_icr, vars.old_icr)
            vars
        else // if Normal Mode
            require_icr_is_above_mcr(vars.new_icr)
            let new_tcr = get_new_tcr_from_trove_change(vars.coll_change, vars.is_coll_increase,
                    vars.net_debt_change, is_debt_increase, vars.price)
            require_new_tcr_is_above_ccr(new_tcr)
            vars { new_tcr = new_tcr }

    function require_icr_is_above_mcr(new_icr: int) =
        require(new_icr >= mcr(), "BorrowerOps: An operation that would result in ICR < MCR is not permitted")

    function require_icr_is_above_ccr(new_icr: int) =
        require(new_icr >= ccr(), "BorrowerOps: Operation must leave trove with ICR >= CCR")

    function require_new_icr_is_above_old_icr(new_icr: int, old_icr: int) =
        require(new_icr >= old_icr, "BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode")

    function require_new_tcr_is_above_ccr(new_tcr: int) =
        require(new_tcr >= ccr(), "BorrowerOps: An operation that would result in TCR < CCR is not permitted")

    function require_at_least_min_net_debt(net_debt: int) =
        require(net_debt >= min_net_debt(), "BorrowerOps: Trove's net debt must be greater than minimum")

    function require_valid_aeusd_repayment(current_debt: int, debt_repayment: int ) =
        require(debt_repayment =< SafeMath.sub(current_debt,aeusd_gas_compensation()),
            "BorrowerOps: Amount repaid must not be larger than the Trove's debt")

    function require_caller_is_stability_pool() = withAddresses( (addresses) =>
            require(Call.caller == addresses.stability_pool.address, "BorrowerOps: Caller is not Stability Pool")
        )

    function require_sufficient_aeusd_balance(
          aeusd_token: IAEUSDToken
        , borrower: address
        , debt_repayment: int
        ) = require(Option.default(0,aeusd_token.balance(borrower)) >= debt_repayment,
            "BorrowerOps: Caller doesnt have enough AEUSD to make repayment")

    //------------------------------------------------------------------------------
    // ICR and TCR getters
    //------------------------------------------------------------------------------

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function get_new_icr_from_trove_change (
        coll: int
        , debt: int
        , coll_change: int
        , is_coll_increase: bool
        , debt_change: int
        , is_debt_increase: bool
        , price: int
        ): int =
        let (new_coll, new_debt) = get_new_trove_amounts(coll, debt, coll_change, is_coll_increase, debt_change, is_debt_increase)

        LiquityMath.compute_cr(new_coll, new_debt, price)

    function get_new_trove_amounts(
          coll: int
        , debt: int
        , coll_change: int
        , is_coll_increase: bool
        , debt_change: int
        , is_debt_increase: bool ): (int*int) =
        let new_debt = debt

        let new_coll = if (is_coll_increase) SafeMath.add(coll,coll_change) else SafeMath.sub(coll,coll_change)
        let new_debt = if (is_debt_increase) SafeMath.add(debt,debt_change) else SafeMath.sub(debt,debt_change)

        (new_coll, new_debt)

    function get_new_tcr_from_trove_change (
          coll_change: int
        , is_coll_increase: bool
        , debt_change: int
        , is_debt_increase: bool
        , price: int ): int =
        let total_coll = get_entire_system_coll()
        let total_debt = get_entire_system_debt()

        let total_coll = if (is_coll_increase) SafeMath.add(total_coll,coll_change)
                         else SafeMath.sub(total_coll,coll_change)
        let total_debt = if (is_debt_increase) SafeMath.add(total_debt,debt_change)
                         else SafeMath.sub(total_debt,debt_change)

        LiquityMath.compute_cr(total_coll, total_debt, price)

    //------------------------------------------------------------------------------
    // OTHER FUNCTIONS
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    // EVENTS
    //------------------------------------------------------------------------------

    datatype event
        = TroveManagerAddressChanged(ITroveManager /*newTroveManagerAddress*/)
        //TODO: will see if we implement this
        /*| GasPoolAddressChanged(address _gasPoolAddress)*/
        | CollSurplusPoolAddressChanged(ICollSurplusPool /*collSurplusPoolAddress*/)
        | PriceFeedAddressChanged(IPriceFeed  /*newPriceFeedAddress*/)
        | SortedTrovesAddressChanged(ISortedTroves /*sortedTrovesAddress*/)
        | AEUSDTokenAddressChanged(IAEUSDToken /*aeusdTokenAddress*/)
        | LQTYStakingAddressChanged(ILQTYStaking /*lqtyStakingAddress*/)
        | GasPoolAddressChanged(address /*gasPoolAddress*/)

        | TroveCreated(address /*indexed borrower*/, int /*uint arrayIndex*/)
        | TroveUpdated(
            address /*indexed _borrower*/
            , string
            /*
            , borrower_operations
            , uint _debt
            , uint _coll
            , uint stake
            */
        )
        | AEUSDBorrowingFeePaid(address /*indexed _borrower*/, int /*_AEUSDFee*/)
//#inject "./interfaces/IPool.events.aes"
//#inject "./dependencies/Ownable.events.aes"

    //------------------------------------------------------------------------------
    // EXTENTIONS
    //------------------------------------------------------------------------------

//#inject "./dependencies/Ownable.functions.aes"
//#inject "./dependencies/LiquityBase.functions.aes"
