// SPDX-License-Identifier: MIT

@compiler >= 6

include "Option.aes"
include "./interfaces/IBorrowerOperations.aes"
include "./interfaces/IStabilityPool.aes"
include "./interfaces/ITroveManager.aes"
include "./interfaces/IAEUSDToken.aes"
include "./interfaces/ISortedTroves.aes"
include "./interfaces/ICommunityIssuance.aes"
include "./interfaces/IActivePool.aes"
include "./interfaces/IDefaultPool.aes"
include "./dependencies/Utils.aes"
include "./dependencies/SafeMath.aes"
include "./dependencies/LiquityMath.aes"
/*include "./dependencies/LiquitySafeMath128.aes"*/

/*
 * The Stability Pool holds AEUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its AEUSD debt gets offset with
 * AEUSD in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of AEUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a AEUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an AE gain, as the AE collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total AEUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and AE gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and AE gain, we simply update two state variables:
 * a product P, and a sum S.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated AE gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated AE gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated AE gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding AE gain
 * can be calculated using the initial deposit, the depositor‚Äôs snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated AE gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion AEUSD has depleted to < 1 AEUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S AE GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated AE gain, during the epoch in which the deposit was non-zero and earned AE.
 *
 * We calculate the depositor's accumulated AE gain for the scale at which they made the deposit, using the AE gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated AE gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / AE gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- LQTY ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An LQTY issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued LQTY in proportion to the deposit as a share of total deposits. The LQTY earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track LQTY gains for depositors, where 'G' is the sum corresponding to LQTY gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
payable contract StabilityPool =
    //------------------------------------------------------------------------------
    // CONSTANTS
    //------------------------------------------------------------------------------

    function scale_factor() = 1000000000

    //------------------------------------------------------------------------------
    // DATA & STATE
    //------------------------------------------------------------------------------
    record addresses = {
        borrower_operations: IBorrowerOperations
      , trove_manager: ITroveManager
      , aeusd_token: IAEUSDToken
      // Needed to check if there are pending liquidations
      , sorted_troves: ISortedTroves
      , community_issuance: ICommunityIssuance
      , active_pool: IActivePool
      , default_pool: IDefaultPool
      , price_feed: IPriceFeed
      }

    record front_end = {
        kickback_rate: int
      , registered: bool
      }
    function no_front_end(): front_end = {
        kickback_rate = 0
      , registered = false
      }

    record deposit = {
        initial_value: int
      , front_end_tag: option(address)
      }
    function no_deposit(): deposit = {
        initial_value = 0
      , front_end_tag = None
      }

    record snapshots = {
        s: int
      , p: int
      , g: int
      , scale: int
      , epoch: int
      }

    function no_snapshots(): snapshots = {
        s = 0
      , p = 0
      , g = 0
      , scale = 0
      , epoch = 0
      }

    record state = {
        owner: option(address)
      , addresses: option(addresses)
      , ae: int  // deposited ae tracker
      // Tracker for AEUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
      , total_aeusd_deposits: int
      , deposits: map(address, deposit) // depositor address -> Deposit struct
      , deposit_snapshots: map(address, snapshots) // depositor address -> snapshots struct
      , front_ends: map(address, front_end) // front end address -> FrontEnd struct
      , front_end_stakes: map(address, int) // front end address -> last recorded total deposits, tagged with that front end
      , front_end_snapshots: map(address, snapshots) // front end address -> snapshots struct
      /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
      * after a series of liquidations have occurred, each of which cancel some AEUSD debt with the deposit.
      *
      * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
      * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
      */
      , p: int
      // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
      , current_scale: int
      // With each offset that fully empties the Pool, the epoch is incremented by 1
      , current_epoch: int
      /* AE Gain sum 'S': During its lifetime, each deposit d_t earns an AE gain of ( d_t * [S - S_t] )/P_t, where S_t
      * is the depositor's snapshot of S taken at the time t when the deposit was made.
      *
      * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
      *
      * - The inner mapping records the sum S at different scales
      * - The outer mapping records the (scale => sum) mappings, for different epochs.
      */
      , epoch_to_scale_to_sum: map((int*int),int)

      /*
      * Similarly, the sum 'G' is used to calculate LQTY gains. During it's lifetime, each deposit d_t earns a LQTY gain of
      *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
      *
      *  LQTY reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
      *  In each case, the LQTY reward is issued (i.e. G is updated), before other state changes are made.
      */
      , epoch_to_scale_to_g: map(int*int,int)
      // Error tracker for the error correction in the LQTY issuance calculation
      , last_lqty_error: int
      // Error trackers for the error correction in the offset calculation
      , last_ae_error_offset: int
      , last_aeusd_loss_error_offset: int
      }

    //------------------------------------------------------------------------------
    // INIT ENTRYPOINTS
    //------------------------------------------------------------------------------

    entrypoint init() = {
        owner = Some(Call.caller)
      , addresses = None
      , ae = 0
      , total_aeusd_deposits = 0
      , deposits = {}
      , deposit_snapshots = {}
      , front_ends = {}
      , front_end_stakes = {}
      , front_end_snapshots = {}
      , p = Utils.decimal_precision()
      , current_scale = 0
      , current_epoch = 0
      , epoch_to_scale_to_sum = {}
      , epoch_to_scale_to_g = {}
      , last_lqty_error = 0
      , last_ae_error_offset = 0
      , last_aeusd_loss_error_offset = 0
      }

    stateful entrypoint set_addresses(addresses: addresses) =
      //requirement
      only_owner()

      put(state{addresses = Some(addresses)})

      Chain.event(BorrowerOperationsAddressChanged(addresses.borrower_operations))
      Chain.event(TroveManagerAddressChanged(addresses.trove_manager))
      Chain.event(ActivePoolAddressChanged(addresses.active_pool))
      Chain.event(AEUSDTokenAddressChanged(addresses.aeusd_token))
      Chain.event(SortedTrovesAddressChanged(addresses.sorted_troves))
      Chain.event(PriceFeedAddressChanged(addresses.price_feed))
      Chain.event(CommunityIssuanceAddressChanged(addresses.community_issuance))
      Chain.event(DefaultPoolAddressChanged(addresses.default_pool))

      renounce_ownership()

    //------------------------------------------------------------------------------
    // DATA GETTERS
    //------------------------------------------------------------------------------

    entrypoint get_ae() = state.ae

    entrypoint get_total_aeusd_deposits() = state.total_aeusd_deposits

    //------------------------------------------------------------------------------
    // REWARD CALCULATOR FUNCTIONS FOR DEPOSITOR AND FRONT END
    //------------------------------------------------------------------------------

    /* Calculates the AE gain earned by the deposit since its last snapshots were taken.
    * Given by the formula:  E = d0 * (S - S(0))/P(0)
    * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
    * d0 is the last recorded deposit value.
    */
    entrypoint get_depositor_ae_gain(depositor: address): int =
        switch(Map.lookup(depositor,state.deposits))
          None => 0
          Some(deposit) | deposit.initial_value == 0 => 0
          Some(deposit) =>
            //TODO: we assume deposit_snapshots[depositor] has sth?
            let snapshots = Map.lookup_default(depositor, state.deposit_snapshots, no_snapshots())
            get_ae_gain_from_snapshots(deposit.initial_value, snapshots)

    function get_ae_gain_from_snapshots(initial_deposit: int, snapshots: snapshots): int =
        /*
        * Grab the sum 'S' from the epoch at which the stake was made. The AE gain may span up to one scale change.
        * If it does, the second portion of the AE gain is scaled by 1e9.
        * If the gain spans no scale change, the second portion will be 0.
        */
        let first_portion = SafeMath.sub(
            Map.lookup_default((snapshots.epoch,snapshots.scale),state.epoch_to_scale_to_sum,0)
          , snapshots.s
          )
        let second_portion = SafeMath.div(
            Map.lookup_default((snapshots.epoch,SafeMath.add(snapshots.scale,1)),state.epoch_to_scale_to_sum,0)
          , scale_factor()
          )

        SafeMath.div(
            SafeMath.div(
                initial_deposit * SafeMath.add(first_portion,second_portion)
              , snapshots.p
              )
          , Utils.decimal_precision()
          )

    /*
    * Return the LQTY gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
    * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
    *
    * D0 is the last recorded value of the front end's total tagged deposits.
    */
    entrypoint get_front_end_lqty_gain(front_end: address): int =
        let front_end_stake = Map.lookup_default(front_end,state.front_end_stakes,0)
        if (front_end_stake == 0) 0
        else
          let kickback_rate = Map.lookup_default(front_end,state.front_ends,no_front_end()).kickback_rate
          let front_end_share = SafeMath.sub(Utils.decimal_precision(),kickback_rate)

          //TODO: be sure this should revert if no snapshot entry
          let snapshots = state.front_end_snapshots[front_end]

          SafeMath.div(
              front_end_share * get_lqty_gain_from_snapshots(front_end_stake, snapshots)
            , Utils.decimal_precision()
            )

    function get_lqty_gain_from_snapshots(initial_stake: int, snapshots: snapshots): int =
       /*
        * Grab the sum 'G' from the epoch at which the stake was made. The LQTY gain may span up to one scale change.
        * If it does, the second portion of the LQTY gain is scaled by 1e9.
        * If the gain spans no scale change, the second portion will be 0.
        */
        let epoch_snapshot = snapshots.epoch
        let scale_snapshot = snapshots.scale
        let g_snapshot = snapshots.g
        let p_snapshot = snapshots.p

        let first_portion = SafeMath.sub(
            state.epoch_to_scale_to_g[(epoch_snapshot , scale_snapshot)]
          , g_snapshot
          )
        let second_portion = SafeMath.div(
            state.epoch_to_scale_to_g[(epoch_snapshot , scale_snapshot + 1)]
          , scale_factor()
          )

        SafeMath.div(
            SafeMath.div(
                initial_stake * SafeMath.add(first_portion,second_portion)
              , p_snapshot
              )
          , Utils.decimal_precision()
          )

    /*
    * Calculate the LQTY gain earned by a deposit since its last snapshots were taken.
    * Given by the formula:  LQTY = d0 * (G - G(0))/P(0)
    * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
    * d0 is the last recorded deposit value.
    */
    entrypoint get_depositor_lqty_gain(depositor: address): int =
        switch(Map.lookup(depositor,state.deposits))
          None => 0
          Some(deposit) | deposit.initial_value == 0 => 0
          Some(deposit) =>
            /*
            * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
            * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
            * which they made their deposit.
            */
            let kickback_rate = switch(deposit.front_end_tag)
              None => Utils.decimal_precision()
              //TODO: is this partial evaluation ok?
              Some(front_end_tag) => state.front_ends[front_end_tag].kickback_rate

            let snapshots = Map.lookup_default(depositor, state.deposit_snapshots, no_snapshots()) 

            SafeMath.div(
                kickback_rate * get_lqty_gain_from_snapshots(deposit.initial_value, snapshots)
              , Utils.decimal_precision()
              )

    //------------------------------------------------------------------------------
    // EXTERNAL DEPOSITOR FUNCTIONS
    //------------------------------------------------------------------------------

    /*  provide_to_sp():
    *
    * - Triggers a LQTY issuance, based on time passed since the last issuance.
    *   The LQTY issuance is shared between *all* depositors and front ends
    * - Tags the deposit with the provided front end tag param, if it's a new deposit
    * - Sends depositor's accumulated gains (LQTY, AE) to depositor
    * - Sends the tagged front end's accumulated LQTY gains to the tagged front end
    * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
    */
    stateful entrypoint provide_to_sp(amount: int, front_end_tag: option(address)) = with_addresses((addresses) =>
        require_front_end_is_registered_or_zero(front_end_tag)
        require_front_end_not_registered(Call.caller)
        require_non_zero_amount(amount)

        let initial_deposit = switch(Map.lookup(Call.caller,state.deposits))
          None => 0
          Some(deposit) => deposit.initial_value

        trigger_lqty_issuance(addresses.community_issuance)

        if (initial_deposit == 0) set_front_end_tag(Call.caller, front_end_tag)
        let depositor_ae_gain = get_depositor_ae_gain(Call.caller)
        let compounded_aeusd_deposit = get_compounded_aeusd_deposit(Call.caller)
        let aeusd_loss = SafeMath.sub(initial_deposit,compounded_aeusd_deposit) // Needed only for event log

        // First pay out any LQTY gains
        let front_end_opt = Map.lookup_default(Call.caller,state.deposits,no_deposit()).front_end_tag
        pay_out_lqty_gains(addresses.community_issuance, Call.caller, front_end_opt)

        // Update front end stake

        switch(front_end_opt)
          None => ()
          Some(front_end) =>
            let compounded_front_end_stake =  get_compounded_front_end_stake(front_end)
            let new_front_end_stake = SafeMath.add(compounded_front_end_stake,amount)
            update_front_end_stake_and_snapshots(front_end, new_front_end_stake)
            Chain.event(FrontEndStakeChanged(front_end, new_front_end_stake, Call.caller))

        send_aeusd_to_stability_pool(Call.caller, amount)

        let new_deposit = SafeMath.add(compounded_aeusd_deposit,amount)
        update_deposit_and_snapshots(Call.caller, new_deposit)
        Chain.event(UserDepositChanged(Call.caller, new_deposit))

        Chain.event(AEGainWithdrawn(Call.caller, depositor_ae_gain, aeusd_loss)) // AEUSD Loss required for event log

        send_ae_gain_to_depositor(depositor_ae_gain)
      )

    /*  withdrawFromSP():
    *
    * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends
    * - Removes the deposit's front end tag if it is a full withdrawal
    * - Sends all depositor's accumulated gains (LQTY, AE) to depositor
    * - Sends the tagged front end's accumulated LQTY gains to the tagged front end
    * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
    *
    * If _amount > userDeposit, the user withdraws all of their compounded deposit.
    */
    stateful entrypoint withdraw_from_sp(amount: int) = with_addresses((addresses) =>
        if (amount != 0) require_no_under_collateralized_troves()
        //we use lookup_default because we wan't a more expressive
        // message error in case require_user_has_deposit fails
        let initial_deposit = Map.lookup_default(Call.caller,state.deposits,no_deposit()).initial_value
        require_user_has_deposit(initial_deposit)

        trigger_lqty_issuance(addresses.community_issuance)

        let depositor_ae_gain = get_depositor_ae_gain(Call.caller)

        let compounded_aeusd_deposit = get_compounded_aeusd_deposit(Call.caller)
        let aeusd_to_withdraw = LiquityMath.min(amount, compounded_aeusd_deposit)
        let aeusd_loss = SafeMath.sub(initial_deposit,compounded_aeusd_deposit) // Needed only for event log

        // First pay out any LQTY gains
        let front_end_opt = state.deposits[Call.caller].front_end_tag
        pay_out_lqty_gains(addresses.community_issuance, Call.caller, front_end_opt)

        // Update front end stake
        switch(front_end_opt)
          None => ()
          Some(front_end) =>
            let compounded_front_end_stake = get_compounded_front_end_stake(front_end)
            let new_front_end_stake = SafeMath.sub(compounded_front_end_stake,aeusd_to_withdraw)
            update_front_end_stake_and_snapshots(front_end, new_front_end_stake)
            Chain.event(FrontEndStakeChanged(front_end, new_front_end_stake, Call.caller))

        send_aeusd_to_depositor(Call.caller, aeusd_to_withdraw)

        // Update deposit
        let new_deposit = SafeMath.sub(compounded_aeusd_deposit,aeusd_to_withdraw)
        update_deposit_and_snapshots(Call.caller, new_deposit)
        Chain.event(UserDepositChanged(Call.caller, new_deposit))

        Chain.event(AEGainWithdrawn(Call.caller, depositor_ae_gain, aeusd_loss))  // AEUSD Loss required for event log

        send_ae_gain_to_depositor(depositor_ae_gain)
      )

    /* withdrawAEGainToTrove:
    * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends
    * - Sends all depositor's LQTY gain to  depositor
    * - Sends all tagged front end's LQTY gain to the tagged front end
    * - Transfers the depositor's entire AE gain from the Stability Pool to the caller's trove
    * - Leaves their compounded deposit in the Stability Pool
    * - Updates snapshots for deposit and tagged front end stake */
    stateful entrypoint withdraw_ae_gain_to_trove(upper_hint: option(address), lower_hint: option(address)) = with_addresses((addresses) =>
        let initial_deposit = Map.lookup_default(Call.caller,state.deposits,no_deposit()).initial_value
        require_user_has_deposit(initial_deposit)
        require_user_has_trove(Call.caller)
        require_user_has_ae_gain(Call.caller)

        trigger_lqty_issuance(addresses.community_issuance)

        let depositor_ae_gain = get_depositor_ae_gain(Call.caller)

        let compounded_aeusd_deposit = get_compounded_aeusd_deposit(Call.caller)
        let aeusd_loss = SafeMath.sub(initial_deposit,compounded_aeusd_deposit) // Needed only for event log

        // First pay out any LQTY gains
        let front_end_opt = state.deposits[Call.caller].front_end_tag
        pay_out_lqty_gains(addresses.community_issuance, Call.caller, front_end_opt)

        // Update front end stake
        switch(front_end_opt)
          None => ()
          Some(front_end) =>
            let new_front_end_stake = get_compounded_front_end_stake(front_end)
            update_front_end_stake_and_snapshots(front_end, new_front_end_stake)
            Chain.event(FrontEndStakeChanged(front_end, new_front_end_stake, Call.caller))

        update_deposit_and_snapshots(Call.caller, compounded_aeusd_deposit)

        /* Emit events before transferring AE gain to Trove.
         This lets the event log make more sense (i.e. so it appears that first the AE gain is withdrawn
        and then it is deposited into the Trove, not the other way around). */
        Chain.event(AEGainWithdrawn(Call.caller, depositor_ae_gain, aeusd_loss))
        Chain.event(UserDepositChanged(Call.caller, compounded_aeusd_deposit))

        put(state{ ae @ ae = SafeMath.sub(ae,depositor_ae_gain) })
        Chain.event(StabilityPoolAEBalanceUpdated(state.ae))
        Chain.event(AESent(Call.caller, depositor_ae_gain))

        addresses.borrower_operations.move_ae_gain_to_trove(
            Call.caller
          , upper_hint
          , lower_hint
          , value = depositor_ae_gain)
      )

    //------------------------------------------------------------------------------
    // LIQUIDATION FUNCTIONS
    //------------------------------------------------------------------------------

    /*
    * Cancels out the specified debt against the AEUSD contained in the Stability Pool (as far as possible)
    * and transfers the Trove's AE collateral from ActivePool to StabilityPool.
    * Only called by liquidation functions in the TroveManager.
    */
    stateful entrypoint offset(debt_to_offset: int, coll_to_add: int) = with_addresses((addresses) =>
        require_caller_is_trove_manager()
        let total_aeusd = state.total_aeusd_deposits // cached to save an SLOAD
        if (total_aeusd == 0 || debt_to_offset == 0) ()
        else
          trigger_lqty_issuance(addresses.community_issuance)

          let (ae_gain_per_unit_staked,aeusd_loss_per_unit_staked) =
            compute_rewards_per_unit_staked(coll_to_add, debt_to_offset, total_aeusd)

          update_reward_sum_and_product(ae_gain_per_unit_staked, aeusd_loss_per_unit_staked)  // updates S and P

          move_offset_coll_and_debt(coll_to_add, debt_to_offset)
      )

    //------------------------------------------------------------------------------
    // OFFSET HELPER FUNCTIONS
    //------------------------------------------------------------------------------
    stateful function compute_rewards_per_unit_staked(
        coll_to_add: int
      , debt_to_offset: int
      , total_aeusd_deposits: int
      ): (int /*ae_gain_per_unit_staked*/ * int /*aeusd_loss_per_unit_staked*/) =
        /*
        * Compute the AEUSD and AE rewards. Uses a "feedback" error correction, to keep
        * the cumulative error in the P and S state variables low:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        let ae_numerator = SafeMath.add(coll_to_add * Utils.decimal_precision(),state.last_ae_error_offset)

        require(debt_to_offset =< total_aeusd_deposits,"Stability: debt_to_offset is greater than total_aeusd_deposits")
        let aeusd_loss_per_unit_staked  =
          if (debt_to_offset == total_aeusd_deposits)
            put(state{ last_aeusd_loss_error_offset = 0 })
            Utils.decimal_precision()  // When the Pool depletes to 0, so does each deposit
          else
            let aeusd_loss_numerator = SafeMath.sub(
                debt_to_offset * Utils.decimal_precision()
              , state.last_aeusd_loss_error_offset)
            /*
            * Add 1 to make error in quotient positive. We want "slightly too much" AEUSD loss,
            * which ensures the error in any given compoundedAEUSDDeposit favors the Stability Pool.
            */
            let aeusd_loss_per_unit_staked = SafeMath.add(SafeMath.div(aeusd_loss_numerator,total_aeusd_deposits),1)
            put(state{ last_aeusd_loss_error_offset
              = SafeMath.sub(aeusd_loss_per_unit_staked * total_aeusd_deposits,aeusd_loss_numerator) })
            aeusd_loss_per_unit_staked

        let ae_gain_per_unit_staked = SafeMath.div(ae_numerator,total_aeusd_deposits)
        put(state{ last_ae_error_offset = SafeMath.sub(ae_numerator,ae_gain_per_unit_staked * total_aeusd_deposits) })

        (ae_gain_per_unit_staked, aeusd_loss_per_unit_staked)

    // Update the Stability Pool reward sum S and product P
    stateful function update_reward_sum_and_product(ae_gain_per_unit_staked: int, aeusd_loss_per_unit_staked: int) =
        let current_p = state.p

        require(aeusd_loss_per_unit_staked =< Utils.decimal_precision(),
          "StabilityPool: aeusd_loss_per_unit_staked is greater than decimal_precision ")

        /*
        * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool AEUSD in the liquidation.
        * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - AEUSDLossPerUnitStaked)
        */
        let new_product_factor = SafeMath.sub(Utils.decimal_precision(),aeusd_loss_per_unit_staked)

        let current_scale = state.current_scale
        let current_epoch = state.current_epoch
        let current_s = Map.lookup_default((current_epoch,current_scale),state.epoch_to_scale_to_sum,0)

        /*
        * Calculate the new S first, before we update P.
        * The AE gain for any given depositor from a liquidation depends on the value of their deposit
        * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
        *
        * Since S corresponds to AE gain, and P to deposit loss, we update S first.
        */
        let marginal_ae_gain = ae_gain_per_unit_staked * current_p
        let new_s = SafeMath.add(current_s,marginal_ae_gain)
        put(state{ epoch_to_scale_to_sum[(current_epoch,current_scale)] = new_s })
        Chain.event(S_Updated(new_s, current_epoch, current_scale))

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        let new_p =
          if (new_product_factor == 0)
            put( state {
                current_epoch = SafeMath.add(current_epoch,1)
              , current_scale = 0
              } )
            Chain.event(ScaleUpdated(state.current_scale))
            Chain.event(EpochUpdated(state.current_epoch))
            Utils.decimal_precision()
          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
          else
            if ( SafeMath.div(current_p * new_product_factor,Utils.decimal_precision()) < scale_factor() )
              put(state{ current_scale = SafeMath.add(current_scale,1) })
              Chain.event(ScaleUpdated(state.current_scale))
              SafeMath.div(current_p * new_product_factor * scale_factor(),Utils.decimal_precision())
            else
              SafeMath.div(current_p * new_product_factor,Utils.decimal_precision())

        require(new_p > 0,"Stability: new_p is not greater than 0")
        put(state{ p = new_p })
        Chain.event(P_Updated(new_p))

    stateful function move_offset_coll_and_debt(coll_to_add: int, debt_to_offset: int) = with_addresses((addresses) =>
        // Cancel the liquidated AEUSD debt with the AEUSD in the stability pool
        addresses.active_pool.decrease_aeusd_debt(debt_to_offset)
        decrease_aeusd(debt_to_offset)

        // Burn the debt that was successfully offset
        addresses.aeusd_token.burn(Contract.address, debt_to_offset)

        addresses.active_pool.send_ae(Contract.address, coll_to_add)
      )

    stateful function decrease_aeusd(amount: int) =
        let new_total_aeusd_deposits = SafeMath.sub(state.total_aeusd_deposits,amount)
        put(state{ total_aeusd_deposits = new_total_aeusd_deposits })
        Chain.event(StabilityPoolAEUSDBalanceUpdated(new_total_aeusd_deposits))
    //------------------------------------------------------------------------------
    // SENDER FUNCTIONS FOR AEUSD DEPOSIT, AE GAINS AND LQTY GAINS
    //------------------------------------------------------------------------------

    stateful function send_aeusd_to_stability_pool(address: address, amount: int) = with_addresses((addresses) =>
        addresses.aeusd_token.send_to_pool(address, Contract.address, amount)
        let new_total_aeusd_deposits = SafeMath.add(state.total_aeusd_deposits,amount)
        put(state{ total_aeusd_deposits = new_total_aeusd_deposits })
        Chain.event(StabilityPoolAEUSDBalanceUpdated(new_total_aeusd_deposits))
      )

    stateful function
      send_ae_gain_to_depositor: (int /*amount*/) => unit
      send_ae_gain_to_depositor(0) = ()
      send_ae_gain_to_depositor(amount) =
        let new_ae = SafeMath.sub(state.ae,amount)
        put(state{ae = new_ae})
        Chain.event(StabilityPoolAEBalanceUpdated(new_ae))
        Chain.event(AESent(Call.caller, amount))

        Chain.spend(Call.caller,amount)

    // Send AEUSD to user and decrease AEUSD in Pool
    stateful function
      send_aeusd_to_depositor: (address /*depositor*/, int /*aeusd_withdrawal*/) => unit
      send_aeusd_to_depositor(_,0) = ()
      send_aeusd_to_depositor(depositor,aeusd_withdrawal) = with_addresses((addresses) =>
          addresses.aeusd_token.return_from_pool(Contract.address, depositor, aeusd_withdrawal)
          decrease_aeusd(aeusd_withdrawal)
        )

    //------------------------------------------------------------------------------
    // EXTERNAL FRONT END FUNCTIONS
    //------------------------------------------------------------------------------

    // Front end makes a one-time selection of kickback rate upon registering
    stateful entrypoint register_front_end(kickback_rate: int) =
        require_front_end_not_registered(Call.caller)
        require_user_has_no_deposit(Call.caller)
        require_valid_kickback_rate(kickback_rate)

        put(state{ front_ends[Call.caller] = { kickback_rate = kickback_rate , registered = true }})

        Chain.event(FrontEndRegistered(Call.caller, kickback_rate))


    //------------------------------------------------------------------------------
    // FALLBACK FUNCTION
    //------------------------------------------------------------------------------
    payable stateful entrypoint receive() =
        require_caller_is_active_pool()
        put(state{ ae @ ae = SafeMath.add(ae,Call.value) })
        Chain.event(StabilityPoolAEBalanceUpdated(state.ae))

    //------------------------------------------------------------------------------
    // LQTY ISSUANCE FUNCTIONS
    //------------------------------------------------------------------------------

    stateful function trigger_lqty_issuance(community_issuance: ICommunityIssuance) =
      let lqty_issuance = community_issuance.issue_lqty()
      update_g(lqty_issuance)

    stateful function
      update_g: (int /*lqty_issuance */) => unit
      /*
      * When total deposits is 0, G is not updated. In this case, the LQTY issued can not be obtained by later
      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
      *
      */
      update_g(lqty_issuance) | state.total_aeusd_deposits == 0 || lqty_issuance == 0 = ()
      update_g(lqty_issuance) =
        let lqty_per_unit_staked =compute_lqty_per_unit_staked(lqty_issuance, state.total_aeusd_deposits)

        let marginal_lqty_gain = lqty_per_unit_staked * state.p

        let (current_epoch,current_scale) = (state.current_epoch,state.current_scale)
        let key = (current_epoch,current_scale)
        put(state{ epoch_to_scale_to_g[key = 0] @ t = SafeMath.add(t,marginal_lqty_gain)})

        Chain.event(G_Updated(state.epoch_to_scale_to_g[key], current_epoch, current_scale))

    stateful function compute_lqty_per_unit_staked(lqty_issuance: int, total_aeusd_deposits: int) =
        /*
        * Calculate the LQTY-per-unit staked.  Division uses a "feedback" error correction, to keep the
        * cumulative error low in the running total G:
        *
        * 1) Form a numerator which compensates for the floor division error that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratio.
        * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
        * 4) Store this error for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        let lqty_numerator = SafeMath.add(lqty_issuance*Utils.decimal_precision(),state.last_lqty_error)

        let lqty_per_unit_staked = SafeMath.div(lqty_numerator,total_aeusd_deposits)
        put(state{ last_lqty_error = SafeMath.sub(lqty_numerator,lqty_per_unit_staked * total_aeusd_deposits) })

        lqty_per_unit_staked

    //------------------------------------------------------------------------------
    // STABILITY POOL DEPOSIT FUNCTIONALITY
    //------------------------------------------------------------------------------

    stateful function set_front_end_tag(depositor: address, front_end_tag: option(address)) =
        put(state{ deposits[depositor = no_deposit()] @ d = d { front_end_tag = front_end_tag}})
        Chain.event(FrontEndTagSet(depositor, Utils.optional_address_to_str(front_end_tag)))

    function pay_out_lqty_gains(community_issuance: ICommunityIssuance, depositor: address, front_end_opt: option(address)) =
        Option.map(
            (front_end) =>
              let front_end_lqty_gain = get_front_end_lqty_gain(front_end)
              community_issuance.send_lqty(front_end, front_end_lqty_gain)
              Chain.event( LQTYPaidToFrontEnd(front_end, front_end_lqty_gain) )
          , front_end_opt
          )

        // Pay out depositor's LQTY gain
        let depositor_lqty_gain = get_depositor_lqty_gain(depositor)
        community_issuance.send_lqty(depositor, depositor_lqty_gain)
        Chain.event(LQTYPaidToDepositor(depositor, depositor_lqty_gain))

    stateful function update_deposit_and_snapshots(depositor: address, new_value: int) =
        if (new_value == 0)
          put(state{
              deposits @ d = Map.delete(depositor,d)
            , deposit_snapshots @ d = Map.delete(depositor,d) })

          Chain.event(DepositSnapshotUpdated(depositor, Utils.xsToPayload([0, 0, 0])))
        else
          let current_scale = state.current_scale
          let current_epoch = state.current_epoch
          let current_p = state.p

          // Get S and G for the current epoch and current scale
          let current_s = Map.lookup_default((current_epoch,current_scale),state.epoch_to_scale_to_sum,0)
          let current_g = Map.lookup_default((current_epoch,current_scale),state.epoch_to_scale_to_g,0)

          // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
          put(state{
              deposits[depositor = no_deposit()] @ d = d { initial_value = new_value}
            , deposit_snapshots[depositor] = {
                p = current_p
              , s = current_s
              , g = current_g
              , scale = current_scale
              , epoch = current_epoch
            }})

          Chain.event(DepositSnapshotUpdated(depositor, Utils.xsToPayload([current_p, current_s, current_g])))

    stateful function update_front_end_stake_and_snapshots(front_end: address, new_value: int) =
        put(state{ front_end_stakes[front_end] = new_value })

        if (new_value == 0)
            put(state{ front_end_snapshots @ t = Map.delete(front_end,t) })
            Chain.event(FrontEndSnapshotUpdated(front_end, 0, 0))
        else
          let current_scale = state.current_scale
          let current_epoch = state.current_epoch
          let current_p = state.p

          // Get G for the current epoch and current scale
          let current_g = Map.lookup_default((current_epoch,current_scale), state.epoch_to_scale_to_g, 0)

          // Record new snapshots of the latest running product P and sum G for the front end
          put(state{ front_end_snapshots[front_end = no_snapshots()] @ s = s {
              p = current_p
            , g = current_g
            , scale = current_scale
            , epoch = current_epoch
            }})

          Chain.event(FrontEndSnapshotUpdated(front_end, current_p, current_g))

    //------------------------------------------------------------------------------
    // COMPOUNDED DEPOSIT AND COMPOUNDED FRONT END STAKE
    //------------------------------------------------------------------------------

    /*
    * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
    * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
    */
    entrypoint get_compounded_aeusd_deposit(depositor: address): int =
        let initial_deposit = Map.lookup_default(depositor,state.deposits,no_deposit()).initial_value
        if(initial_deposit == 0) 0
        else
          let snapshots = Map.lookup_default(depositor, state.deposit_snapshots, no_snapshots())
          get_compounded_stake_from_snapshots(initial_deposit, snapshots)

    /*
    * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
    * where P(0) is the depositor's snapshot of the product P, taken at the last time
    * when one of the front end's tagged deposits updated their deposit.
    *
    * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
    */
    entrypoint get_compounded_front_end_stake(front_end: address): int =
        let front_end_stake = Map.lookup_default(front_end,state.front_end_stakes,0)
        if(front_end_stake == 0) 0
        else
          let snapshots = Map.lookup_default(front_end, state.front_end_snapshots, no_snapshots())
          get_compounded_stake_from_snapshots(front_end_stake, snapshots)

    // Internal function, used to calculcate compounded deposits and compounded front end stakes.
    function get_compounded_stake_from_snapshots( initial_stake: int, snapshots: snapshots ): int =
        let scale_snapshot = snapshots.scale
        let epoch_snapshot = snapshots.epoch

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epoch_snapshot < state.current_epoch) 0
        else
          let scale_diff = SafeMath.sub(state.current_scale, scale_snapshot)
          /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
          * account for it. If more than one scale change was made, then the stake has decreased by a factor of
          * at least 1e-9 -- so return 0.
          */
          let compounded_stake =
            if (scale_diff == 0) SafeMath.div(initial_stake * state.p, snapshots.p)
            else
              if (scale_diff == 1) SafeMath.div(
                    SafeMath.div(initial_stake * state.p, snapshots.p)
                  , scale_factor()
                  )
              else 0 // if scaleDiff >= 2

          /*
          * If compounded deposit is less than a billionth of the initial deposit, return 0.
          *
          * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
          * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
          * than it's theoretical value.
          *
          * Thus it's unclear whether this line is still really needed.
          */
          if (compounded_stake < SafeMath.div(initial_stake, 1000000000)) 0
          else compounded_stake

    //------------------------------------------------------------------------------
    // CONSTRAINTS
    //------------------------------------------------------------------------------

    function require_caller_is_active_pool() = with_addresses((addresses) =>
        require( Call.caller == addresses.active_pool.address, "StabilityPool: Caller is not ActivePool")
      )

    function require_caller_is_trove_manager() = with_addresses((addresses) =>
        require(Call.caller == addresses.trove_manager.address, "StabilityPool: Caller is not TroveManager")
      )

    function require_no_under_collateralized_troves() = with_addresses((addresses) =>
        let price = addresses.price_feed.fetch_price()
        let lowest_trove_option = addresses.sorted_troves.get_last()
        switch(lowest_trove_option)
          None => abort("StabilityPool: lowest_trove is None")
          Some(lowest_trove) =>
            let icr = addresses.trove_manager.get_current_icr(lowest_trove, price)
            require(icr >= mcr(), "StabilityPool: Cannot withdraw while there are troves with ICR < MCR")
      )

    function require_user_has_deposit(initial_deposit: int) =
        require(initial_deposit > 0, "StabilityPool: User must have a non-zero deposit")

    function require_user_has_no_deposit(address: address) =
        switch(Map.lookup(address,state.deposits))
          None => ()
          Some(deposit) => require(deposit.initial_value == 0, "StabilityPool: User must have no deposit")

    function require_non_zero_amount(amount: int) =
        require(amount > 0, "StabilityPool: Amount must be non-zero")

    function require_user_has_trove(depositor: address) = with_addresses((addresses) =>
        require( addresses.trove_manager.get_trove_status(depositor) == 1,
          "StabilityPool: caller must have an active trove to withdraw AEGain to"))

    function require_user_has_ae_gain(depositor: address) =
        let ae_gain = get_depositor_ae_gain(depositor)
        require(ae_gain > 0, "StabilityPool: caller must have non-zero AE Gain")

    function require_front_end_not_registered(address: address) =
        switch(Map.lookup(address,state.front_ends))
          None => ()
          Some(front_end) => require(!front_end.registered,
            "StabilityPool: must not already be a registered front end")

    function require_front_end_is_registered_or_zero(address_opt: option(address)) =
        switch(address_opt)
          None => ()
          Some(address) => switch(Map.lookup(address,state.front_ends))
            None => ()
            Some(front_end) => require(!front_end.registered,
              "StabilityPool: Tag must be a registered front end, or no address")

    function  require_valid_kickback_rate(kickback_rate: int) =
        require (kickback_rate =< Utils.decimal_precision(),
          "StabilityPool: Kickback rate must be in range [0,1]" )

    //------------------------------------------------------------------------------
    // EVENTS
    //------------------------------------------------------------------------------

    datatype event
      = StabilityPoolAEBalanceUpdated(int /*newBalance*/)
      | StabilityPoolAEUSDBalanceUpdated(int /*newBalance*/)

      | BorrowerOperationsAddressChanged(IBorrowerOperations /*newBorrowerOperationsAddress*/)
      | TroveManagerAddressChanged(ITroveManager /*newTroveManagerAddress*/)
      | ActivePoolAddressChanged(IActivePool /*newActivePoolAddress*/)
      | DefaultPoolAddressChanged(IDefaultPool /*newDefaultPoolAddress*/)
      | AEUSDTokenAddressChanged(IAEUSDToken /*newAEUSDTokenAddress*/)
      | SortedTrovesAddressChanged(ISortedTroves /*newSortedTrovesAddress*/)
      | PriceFeedAddressChanged(IPriceFeed /*newPriceFeedAddress*/)
      | CommunityIssuanceAddressChanged(ICommunityIssuance /*newCommunityIssuanceAddress*/)

      | P_Updated(int /*P*/)
      | S_Updated(int /*S*/, int /*epoch*/, int /*scale*/)
      | G_Updated(int /*G*/, int /*epoch*/, int /*scale*/)
      | EpochUpdated(int /*currentEpoch*/)
      | ScaleUpdated(int /*currentScale*/)

      | FrontEndRegistered(address /*frontEnd*/, int /*kickbackRate*/)
      | FrontEndTagSet(address /*depositor*/, string /*frontEnd: option(address)*/)

      | DepositSnapshotUpdated(
            address /*depositor*/
          , string
          /*
          , int P
          , int S
          , int G
          */
          )
      | FrontEndSnapshotUpdated(address /*frontEnd*/, int /*P*/, int /*G*/)
      | UserDepositChanged(address /*depositor*/, int /*newDeposit*/)
      | FrontEndStakeChanged(
            address /*frontEnd*/
          , int /*newFrontEndStake*/
          , address /*depositor*/
          )

      | AEGainWithdrawn(address /*depositor*/, int /*AE*/, int /*AEUSDLoss*/)
      | LQTYPaidToDepositor(address /*depositor*/, int /*LQTY*/)
      | LQTYPaidToFrontEnd(address /*frontEnd*/, int /*LQTY*/)
      | AESent(address /*to*/, int /*amount*/)
//#inject "./dependencies/Ownable.events.aes"

    //------------------------------------------------------------------------------
    // EXTENTIONS
    //------------------------------------------------------------------------------
//#inject "./dependencies/Ownable.functions.aes"
//#inject "./dependencies/LiquityBase.functions.aes"
