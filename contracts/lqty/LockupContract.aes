@compiler >= 6

include "Option.aes"
include "String.aes"
include "../interfaces/ILQTYToken.aes"
include "../dependencies/SafeMath.aes"
include "../dependencies/Utils.aes"

/*
* The lockup contract architecture utilizes a single LockupContract, with an unlockTime. The unlockTime is passed as an argument 
* to the LockupContract's constructor. The contract's balance can be withdrawn by the beneficiary when block.timestamp > unlockTime. 
* At construction, the contract checks that unlockTime is at least one year later than the Liquity system's deployment time. 

* Within the first year from deployment, the deployer of the LQTYToken (Liquity AG's address) may transfer LQTY only to valid 
* LockupContracts, and no other addresses (this is enforced in LQTYToken.sol's transfer() function).
* 
* The above two restrictions ensure that until one year after system deployment, LQTY tokens originating from Liquity AG cannot 
* enter circulating supply and cannot be staked to earn system revenue.
*/

contract LockupContract =

    record addresses = {
	  lqty_token: ILQTYToken
	, beneficiary: address
        }

    record state = {
          unlock_time: int
	, addresses: option(addresses)
        }

    entrypoint init() =
        {  
	   addresses = None
	 , unlock_time = 0
         }

    // constants
    function seconds_in_one_year() : int = 31536000

    stateful entrypoint set_addresses(addresses: addresses, unlock_time: int) =
      put(state{addresses = Some(addresses)})

      /*
      * Set the unlock time to a chosen instant in the future, as long as it is at least 1 year after
      * the system was deployed 
      */
      require_unlock_time_is_at_least_one_year_after_system_deployment(unlock_time)
      put(state { unlock_time = unlock_time })

      Chain.event(LockupContractCreated(addresses.beneficiary, unlock_time))

    stateful entrypoint withdraw_lqty() = with_addresses((addresses) =>
        require_caller_is_beneficiary()
        require_lockup_duration_passed()

        let lqty_balance = addresses.lqty_token.balance_of(Contract.address)
	addresses.lqty_token.transfer(addresses.beneficiary, lqty_balance)
	Chain.event(LockupContractEmptied(lqty_balance))
      )

    // --- 'require' functions --- 
    function require_caller_is_beneficiary() : unit = with_addresses((addresses) =>
        require(addresses.beneficiary == Call.caller , "LockupContract: caller is not the beneficiary")
      )

    function require_lockup_duration_passed() : unit = 
      require(Chain.timestamp >= state.unlock_time , "LockupContract: The lockup duration must have passed")

    function require_unlock_time_is_at_least_one_year_after_system_deployment(unlock_time: int) : unit = with_addresses((addresses) =>
        let system_deployment_time = addresses.lqty_token.get_deployment_start_time()
        require(unlock_time >= SafeMath.add(system_deployment_time, seconds_in_one_year()) , "LockupContract: unlock time must be at least one year after system deployment")
      )

    // helper functions

    function with_addresses(f: (addresses) => 'a ): 'a = switch(state.addresses)
      None => abort("LQTYToken: no addresses")
      Some(addresses) => f(addresses)

    // --- Events ---
    datatype event
      = LockupContractCreated(address /*beneficiary*/, int /*unlockTime*/)
      | LockupContractEmptied(int /*lqtyWithdrawal*/)
    


    
