@compiler >= 6

include "Option.aes"
include "String.aes"
include "../interfaces/ILQTYToken.aes"
include "../interfaces/ICommunityIssuance.aes"
include "../interfaces/IStabilityPool.aes"
include "../interfaces/ILQTYStaking.aes"
include "../interfaces/ILockupContractFactory.aes"	
include "../dependencies/LiquityMath.aes"
include "../dependencies/SafeMath.aes"
include "../dependencies/Utils.aes"

/*
* Based upon AEX9 https://github.com/aeternity/AEXs/blob/master/AEXS/aex-9.md https://github.com/mradkov/aeternity-fungible-token/blob/master/contracts/fungible-token.aes
*  
* and their EIP2612 (ERC20Permit / ERC712) functionality:
* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol
* TODO: check if above functionality is important This ERC extends the ERC-20 standard with a new function permit, which allows users to modify the allowance mapping using a signed message, instead of through msg.sender.
*
*  --- Functionality added specific to the LQTYToken ---
* 
* 1) Transfer protection: blacklist of addresses that are invalid recipients (i.e. core Liquity contracts) in external 
* transfer() and transferFrom() calls. The purpose is to protect users from losing tokens by mistakenly sending LQTY directly to a Liquity
* core contract, when they should rather call the right function.
*
* 2) sendToLQTYStaking(): callable only by Liquity core contracts, which move LQTY tokens from user -> LQTYStaking contract.
*
* 3) Supply hard-capped at 100 million
*
* 4) CommunityIssuance and LockupContractFactory addresses are set at deployment
*
* 5) The bug bounties / hackathons allocation of 2 million tokens is minted at deployment to an EOA

* 6) 32 million tokens are minted at deployment to the CommunityIssuance contract
*
* 7) The LP rewards allocation of (1 + 1/3) million tokens is minted at deployent to a Staking contract
*
* 8) (64 + 2/3) million tokens are minted at deployment to the Liquity multisig
*
* 9) Until one year from deployment:
* -Liquity multisig may only transfer() tokens to LockupContracts that have been deployed via & registered in the 
*  LockupContractFactory 
* -create_allowance(), change_allowance(), reset_allowance() revert when called by the multisig
* -transferFrom() reverts when the multisig is the sender
* -sendToLQTYStaking() reverts when the multisig is the sender, blocking the multisig from staking its LQTY.
* 
* After one year has passed since deployment of the LQTYToken, the restrictions on multisig operations are lifted
* and the multisig has the same rights as any other address.
*/

contract LQTYToken =
    //------------------------------------------------------------------------------
    // DATA & STATE
    //------------------------------------------------------------------------------
	
    record meta_info = {
          name : string
	, symbol : string
	, decimals : int
	}

    record allowance_accounts = {
          from_account : address
	, for_account : address
	}

    record state = {
          owner: address
    	, community_issuance: ICommunityIssuance
	, lqty_staking: ILQTYStaking
	, lockup_contract_factory: ILockupContractFactory
	, bounty: address
	, multisig: address	
	// AX9 token data
	, balances: map(address, int) 
	, total_supply: int
	// Extension Allowance                                                                                                                                                                                                                              
	, allowances: map(address, map(address, int))	
	, deployment_start_time: int
	, lp_rewards_entitlement: int
        }

    //------------------------------------------------------------------------------
    // CONSTANTS
    //------------------------------------------------------------------------------

    function one_million() : int = 1000000000000000000000000 // 1e24
    function one_year_in_miliseconds() : int = 31536000000  // 60 * 60 * 24 * 365 * 1000

    entrypoint init(
           community_issuance: ICommunityIssuance
	 , lqty_staking: ILQTYStaking
	 , lockup_contract_factory: ILockupContractFactory
	 , bounty: address
	 , lp_reward: address
	 , multisig: address	
	) =
      // --- Initial LQTY allocations ---
      let bounty_entitlement = one_million() * 2 // Allocate 2 million for bounties/hackathons
      Chain.event(Mint(bounty, bounty_entitlement))

      let depositors_and_frontends_entitlement = one_million() * 32 // Allocate 32 million to the algorithmic issuance schedule
      Chain.event(Mint(community_issuance.address, depositors_and_frontends_entitlement))

      // TODO: lp_reward is not used never in original Solidity contract, just initial mint, what is the purpose ?
      let lp_rewards_entitlement = one_million() * 4 / 3
      Chain.event(Mint(lp_reward, lp_rewards_entitlement))

      let multisig_entitlement = one_million() * 100 - bounty_entitlement - depositors_and_frontends_entitlement - lp_rewards_entitlement
                                                                                                                   
      Chain.event(Mint(multisig, multisig_entitlement))
	
      {  owner = Call.caller
       , community_issuance = community_issuance
       , lqty_staking = lqty_staking
       , lockup_contract_factory = lockup_contract_factory
       , bounty = bounty
       , multisig = multisig
       , balances = Map.from_list([(bounty,bounty_entitlement), (community_issuance.address, depositors_and_frontends_entitlement), (lp_reward, lp_rewards_entitlement), (multisig, multisig_entitlement)])
       , allowances = {}
       , total_supply = bounty_entitlement + depositors_and_frontends_entitlement + lp_rewards_entitlement + multisig_entitlement
       , deployment_start_time = Chain.timestamp
       , lp_rewards_entitlement = lp_rewards_entitlement
       }


    // --- External functions ---
    // AEX9 interface
    entrypoint aex9_extensions(): list(string) = ["mintable", "allowance"]

    // --- AX9 meta information --
    entrypoint meta_info(): meta_info = {name = "LQTY", symbol = "LQTY", decimals = 18}
    
    entrypoint total_supply(): int = state.total_supply

    entrypoint balance(account: address): option(int) = Map.lookup(account, state.balances)

    entrypoint balances(): map(address, int) = state.balances

    entrypoint get_deployment_start_time(): int = state.deployment_start_time

    entrypoint get_lp_rewards_entitlement(): int = state.lp_rewards_entitlement

    stateful entrypoint transfer(recipient: address, amount: int) : unit =
      // Restrict the multisig's transfers in first year
      if (caller_is_multisig()  && is_first_year())
      	 require_recipient_is_registered_lc(recipient)

      require_valid_recipient(recipient)

      // Otherwise, standard transfer functionality
      transfer_allowance(Call.caller, recipient, amount)

    // TODO: is this part of AEX9 Allowance extension 
    entrypoint allowance(allowance_accounts: allowance_accounts) : option(int) =
      Option.flat_map( (m) => Map.lookup(allowance_accounts.for_account, m)
                     , Map.lookup(allowance_accounts.from_account, state.allowances)
		     )
    
    // TODO: is called approve in solidity contract
    stateful entrypoint create_allowance(for_account: address, value: int) =
      if (is_first_year())
      	 require_caller_is_not_multisig()

      allowance_internal(Call.caller, for_account, value)

    // TODO: transfer_from in solidity contract
    stateful entrypoint transfer_allowance(sender: address,  recipient: address, amount: int) : unit =
      if (is_first_year())
      	 require_caller_is_not_multisig()

      require_valid_recipient(recipient)

      transfer_internal(sender, recipient, amount)
      allowance_internal(sender, Call.caller, SafeMath.add(state.allowances[sender][Call.caller], amount))
    
    stateful entrypoint change_allowance(sender: address,  recipient: address, amount: int) : unit =
      if (is_first_year())
      	 require_caller_is_not_multisig()

      require_valid_recipient(recipient)

      transfer_internal(sender, recipient, amount)
      allowance_internal(sender, Call.caller, SafeMath.add(state.allowances[sender][Call.caller], amount))

    // Resets the allowance given `for_account` to zero.
    stateful entrypoint reset_allowance(for_account: address) =
      if (is_first_year())
      	 require_caller_is_not_multisig()

      allowance_internal(Call.caller, for_account, 0)

    stateful entrypoint send_to_lqty_staking(sender: address, amount: int) : unit = 
      require_caller_is_lqty_staking()
      
      if (is_first_year())
       require_sender_is_not_multisig(sender)
	 
      transfer_internal(sender, state.lqty_staking.address, amount)
      
    // --- Internal operations ---

    stateful function transfer_internal(sender: address, recipient: address, amount: int) : unit =
      require_non_negative_value(amount)
      require_balance(sender, amount)

      put( state { balances @ b = b { [sender] @ s = s - amount
                                    , [recipient] @ r = r + amount
				    }
                 }
	)
      Chain.event(Transfer(sender, recipient, amount))

    stateful function allowance_internal(owner: address,spender: address, amount: int) =
      require_non_negative_value(amount)    
      put( state { allowances[owner][spender] = amount })
      Chain.event(Allowance(owner, spender, amount))

    // helper functions

    function caller_is_multisig() : bool = 
      Call.caller == state.multisig


    function is_first_year() : bool =
      Chain.timestamp - state.deployment_start_time < one_year_in_miliseconds() 

    // --- Requirements
    
    function require_non_negative_value(value : int) : unit  =
      require(value >= 0, "NON_NEGATIVE_VALUE_REQUIRED")

    function require_balance(account : address, value : int) : unit =
      switch(balance(account))
        Some(balance) =>
      	  require(balance >= value, "ACCOUNT_INSUFFICIENT_BALANCE")
	None => abort("BALANCE_ACCOUNT_NOT_EXISTENT")

    function require_valid_recipient(recipient: address) : unit = 
      require(recipient != Contract.address, "LQTY: Cannot transfer tokens directly to the LQTY token contract or the zero address")

      require(recipient != state.community_issuance.address && recipient != state.lqty_staking.address, "LQTY: Cannot transfer tokens directly to the community issuance or staking contract")

    function require_recipient_is_registered_lc(recipient: address) : unit = 
      require(state.lockup_contract_factory.is_registered_lockup(recipient), "LQTYToken: recipient must be a LockupContract registered in the Factory")

      
    function require_sender_is_not_multisig(sender: address) : unit = 
      require(sender != state.multisig, "LQTYToken: sender must not be the multisig")

    function require_caller_is_not_multisig() : unit = 
      require(! caller_is_multisig() , "LQTYToken: caller must not be the multisig")


    function require_caller_is_lqty_staking() : unit = 
      require(Call.caller == state.lqty_staking.address, "LQTYToken: caller must be the LQTYStaking contract")


    // --- Events ---
    datatype event
      = CommunityIssuanceAddressSet(ICommunityIssuance /*communityIssuanceAddress*/)
      | LQTYStakingAddressSet(ILQTYStaking /*lqtyStaking*/)
      | LockupContractFactoryAddressSet(ILockupContractFactory /*lockupContractFactory*/)
      // AEX9 Events
      | Allowance(indexed address /*owner*/, indexed address /*spender*/, indexed int /*amount*/)
      | Mint(indexed address /*account*/, indexed int /*amount*/)             
      | Transfer(indexed address /*sender*/, indexed address /*receiver*/, indexed int /*amount*/)       
      // TODO: Specification says sender is just an address not an option, option is only used when minting

