@compiler >= 6


include "Option.aes"
include "./interfaces/ITroveManager.aes"
include "./interfaces/IStabilityPool.aes"
include "./interfaces/ICollSurplusPool.aes"
include "./interfaces/IAEUSDToken.aes"
include "./interfaces/ISortedTroves.aes"
include "./interfaces/ILQTYToken.aes"
include "./interfaces/ILQTYStaking.aes"
include "./interfaces/IBorrowerOperations.aes"
include "./dependencies/SafeMath.aes"
include "./dependencies/LiquityMath.aes"
include "./dependencies/Utils.aes"
include "./interfaces/IDefaultPool.aes"
include "./interfaces/IPriceFeed.aes"

contract TroveManager =

    //------------------------------------------------------------------------------
    // CONSTANTS
    //------------------------------------------------------------------------------

    function seconds_in_one_minute() = 60
    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    function minute_decay_factor() = 999037758833783000
    function redemption_fee_floor() = Utils.decimal_precision() / 1000 * 5 // 0.5%
    function max_borrowing_fee() = Utils.decimal_precision() / 100 * 5 // 5%

    // During bootsrap period redemptions are not allowed
    function bootstrap_period() = 1209600  // 14 days

    /*
    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.
    * Corresponds to (1 / ALPHA) in the white paper.
    */
    function beta() = 2
    //------------------------------------------------------------------------------
    // DATA & STATE
    //------------------------------------------------------------------------------

    record addresses = {
        borrower_operations: IBorrowerOperations
      , stability_pool: IStabilityPool
      , gas_pool: address
      , coll_surplus_pool: ICollSurplusPool
      , aeusd_token: IAEUSDToken
      , lqty_token: ILQTYToken
      , lqty_staking: ILQTYStaking
      , sorted_troves: ISortedTroves
      , default_pool: IDefaultPool
      , active_pool: IActivePool
      , price_feed: IPriceFeed
      }
    record state =  {
        owner: option(address)
      , addresses: option(addresses)
      , base_rate: int
        // The timestamp of the latest fee operation (redemption or new AEUSD issuance)
      , last_fee_operation_time: int
      , troves: map(address,trove)
      , total_stakes: int
      // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
      , total_stakes_snapshot: int
      // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
      , total_collateral_snapshot: int
      /*
      * L_AE and L_AEUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:
      *
      * An AE gain of ( stake * [L_AE - L_AE(0)] )
      * A AEUSDDebt increase  of ( stake * [L_AEUSDDebt - L_AEUSDDebt(0)] )
      *
      * Where L_AE(0) and L_AEUSDDebt(0) are snapshots of L_AE and L_AEUSDDebt for the active Trove taken at the instant the stake was made
      */
      , l_ae: int
      , l_aeusd_debt: int
      // Map addresses with active troves to their RewardSnapshot
      , reward_snapshots:  map (address, reward_snapshot)
      // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
      //TODO: this might be canged with a Set
      , trove_owners: list(address)
      // Error trackers for the trove redistribution calculation
      , last_ae_error_redistribution: int
      , last_aeusd_debt_error_redistribution: int
      }

    datatype status
      = NonExistent
      | Active
      | ClosedByOwner
      | ClosedByLiquidation
      | ClosedByRedemption

    datatype trove_manager_operation
      = ApplyPendingRewards
      | LiquidateInNormalMode
      | LiquidateInRecoveryMode
      | RedeemCollateral

    function
      trove_manager_operation_to_str: (trove_manager_operation) => string
      trove_manager_operation_to_str(ApplyPendingRewards)     = "ApplyPendingRewards"
      trove_manager_operation_to_str(LiquidateInNormalMode)   = "LiquidateInNormalMode"
      trove_manager_operation_to_str(LiquidateInRecoveryMode) = "LiquidateInRecoveryMode"
      trove_manager_operation_to_str(RedeemCollateral)        = "RedeemCollateral"

    // Store the necessary data for a trove
    record trove = {
        debt: int
      , coll: int
      , stake: int
      , status: status
      , array_index: int
      }
    // Object containing the AE and AEUSD snapshots for a given active trove
    record reward_snapshot = {ae: int, aeusd_debt: int}

    /*
    * --- Variable container records for liquidations ---
    *
    * These records are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    //TODO: remove if not used at the end of first implementation
    record outer_liquidation_function = {
        price: int
      , aeusd_in_stab_pool: int
      , recovery_mode_at_start: bool
      , liquidated_debt: int
      , liquidated_coll: int
      }
    function init_outer_liquidation_function_var(): outer_liquidation_function = {
        price = 0
      , aeusd_in_stab_pool = 0
      , recovery_mode_at_start = false
      , liquidated_debt = 0
      , liquidated_coll = 0
      }

    record inner_single_liquidate_function = {
        coll_to_liquidate: int
      , pending_debt_reward: int
      , pending_coll_reward: int
      }

    record liquidation_sequence = {
        remaining_aeusd_in_stab_pool: int
      /*, i: int*/
      , icr: int
      /*, user: address*/
      , back_to_normal_mode: bool
      , entire_system_debt: int
      , entire_system_coll: int
      }
    function init_liquidation_sequence() = {
        remaining_aeusd_in_stab_pool = 0
      /*, i = 0*/
      , icr = 0
      /*, user = user*/
      , back_to_normal_mode = false
      , entire_system_debt = 0
      , entire_system_coll = 0
      }

    record liquidation_values = {
        entire_trove_debt: int
      , entire_trove_coll: int
      , coll_gas_compensation: int
      , aeusd_gas_compensation: int
      , debt_to_offset: int
      , coll_to_send_to_sp: int
      , debt_to_redistribute: int
      , coll_to_redistribute: int
      , coll_surplus: int
      }
    function init_liquidation_values() = {
        entire_trove_debt = 0
      , entire_trove_coll = 0
      , coll_gas_compensation = 0
      , aeusd_gas_compensation = 0
      , debt_to_offset = 0
      , coll_to_send_to_sp = 0
      , debt_to_redistribute = 0
      , coll_to_redistribute = 0
      , coll_surplus = 0
      }

    record liquidation_totals = {
        total_coll_in_sequence: int
      , total_debt_in_sequence: int
      , total_coll_gas_compensation: int
      , total_aeusd_gas_compensation: int
      , total_debt_to_offset: int
      , total_coll_to_send_to_sp: int
      , total_debt_to_redistribute: int
      , total_coll_to_redistribute: int
      , total_coll_surplus: int
      }
    function init_liquidation_totals(): liquidation_totals = {
        total_coll_in_sequence = 0
      , total_debt_in_sequence = 0
      , total_coll_gas_compensation = 0
      , total_aeusd_gas_compensation = 0
      , total_debt_to_offset = 0
      , total_coll_to_send_to_sp = 0
      , total_debt_to_redistribute = 0
      , total_coll_to_redistribute = 0
      , total_coll_surplus = 0
      }

    record contracts_cache = {
        active_pool: IActivePool
      , default_pool: IDefaultPool
      , aeusd_token: IAEUSDToken
      , lqty_staking: ILQTYStaking
      , sorted_troves: ISortedTroves
      , coll_surplus_pool: ICollSurplusPool
      , gas_pool_address: address
      }

    /*// --- Variable container records for redemptions ---*/

    record redemption_totals = {
        remaining_aeusd: int
      , total_aeusd_to_redeem: int
      , total_ae_drawn: int
      , ae_fee: int
      , ae_to_send_to_redeemer: int
      , decayed_base_rate: int
      , price: int
      , total_aeusd_supply_at_start: int
      }

    record single_redemption_values = {
        aeusd_lot: int
      , ae_lot: int
      , cancelled_partial: int
      }

    //------------------------------------------------------------------------------
    // INIT ENTRYPOINTS
    //------------------------------------------------------------------------------

    entrypoint init() =
      {  owner = None
       , addresses = None
       , base_rate = 0
       , last_fee_operation_time = 0
       , troves = {}
       , total_stakes = 0
       , total_stakes_snapshot = 0
       , total_collateral_snapshot = 0
       , l_ae = 0
       , l_aeusd_debt = 0
       , reward_snapshots = {}
       , trove_owners = []
       , last_ae_error_redistribution = 0
       , last_aeusd_debt_error_redistribution = 0
       }

    stateful entrypoint set_addresses(addresses: addresses) =
      //requirement
      only_owner()

      put(state{addresses = Some(addresses)})

      Chain.event(BorrowerOperationsAddressChanged(addresses.borrower_operations))
      Chain.event(ActivePoolAddressChanged(addresses.active_pool))
      Chain.event(DefaultPoolAddressChanged(addresses.default_pool))
      Chain.event(StabilityPoolAddressChanged(addresses.stability_pool))
      Chain.event(GasPoolAddressChanged(addresses.gas_pool))
      Chain.event(CollSurplusPoolAddressChanged(addresses.coll_surplus_pool))
      Chain.event(PriceFeedAddressChanged(addresses.price_feed))
      Chain.event(AEUSDTokenAddressChanged(addresses.aeusd_token))
      Chain.event(SortedTrovesAddressChanged(addresses.sorted_troves))
      Chain.event(LQTYTokenAddressChanged(addresses.lqty_token))
      Chain.event(LQTYStakingAddressChanged(addresses.lqty_staking))

      renounce_ownership()

    //------------------------------------------------------------------------------
    // DATA GETTERS
    //------------------------------------------------------------------------------

    entrypoint get_trove_owners_count() = List.length(state.trove_owners)

    entrypoint get_trove_from_trove_owners_array(index: int): option(address) =
      List.nth(index,state.trove_owners)


    //------------------------------------------------------------------------------
    // TROVE LIQUIDATION FUNCTIONS
    //------------------------------------------------------------------------------

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    stateful entrypoint liquidate(borrower: address) =
        require_trove_is_active(borrower)
        batch_liquidate_troves([borrower])

    stateful function batch_liquidate_troves(trove_array: list(address)) = with_addresses((addresses) =>
        require(List.length(trove_array) != 0, "TroveManager: Calldata address array must not be empty")

        let active_pool = addresses.active_pool
        let default_pool = addresses.default_pool
        let stability_pool = addresses.stability_pool

        let price = addresses.price_feed.fetch_price()
        let aeusd_in_stab_pool = stability_pool.get_total_aeusd_deposits()
        let recovery_mode_at_start = check_recovery_mode(price)

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        let totals =
          if (recovery_mode_at_start)
            get_total_from_batch_liquidate_recovery_mode( active_pool, default_pool, price
                                                        , aeusd_in_stab_pool, trove_array )
          else
            get_totals_from_batch_liquidate_normal_mode(active_pool, default_pool, price
                                                       , aeusd_in_stab_pool, trove_array )

        require(totals.total_debt_in_sequence > 0, "TroveManager: nothing to liquidate")

        // Move liquidated AE and AEUSD to the appropriate pools
        stability_pool.offset(totals.total_debt_to_offset, totals.total_coll_to_send_to_sp)
        redistribute_debt_and_coll(
            active_pool
          , default_pool
          , totals.total_debt_to_redistribute
          , totals.total_coll_to_redistribute
          )
        if (totals.total_coll_surplus > 0)
            active_pool.send_ae(addresses.coll_surplus_pool.address, totals.total_coll_surplus)

        // Update system snapshots
        update_system_snapshots_exclude_coll_remainder(active_pool, totals.total_coll_gas_compensation)

        let liquidated_debt = totals.total_debt_in_sequence
        let liquidated_coll = SafeMath.sub(
            SafeMath.sub(totals.total_coll_in_sequence,totals.total_coll_gas_compensation)
          , totals.total_coll_surplus
          )

        Chain.event( Liquidation(
            liquidated_debt
          , liquidated_coll
          , Utils.xsToPayload([totals.total_coll_gas_compensation, totals.total_aeusd_gas_compensation])
          ))
        // Send gas compensation to caller
        send_gas_compensation(
            active_pool
          , Call.caller
          , totals.total_aeusd_gas_compensation
          , totals.total_coll_gas_compensation
          )
      )

    /*
    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
    */
    stateful function get_total_from_batch_liquidate_recovery_mode (
        active_pool: IActivePool
      , default_pool: IDefaultPool
      , price: int
      , aeusd_in_stab_pool: int
      , trove_array: list(address)
      ): liquidation_totals =
      let vars = init_liquidation_sequence() {
          remaining_aeusd_in_stab_pool = aeusd_in_stab_pool
        , back_to_normal_mode = false
        , entire_system_debt = get_entire_system_debt()
        , entire_system_coll = get_entire_system_coll()
        }
      let totals = init_liquidation_totals()
      total_rec_mode_loop(totals,vars,active_pool,default_pool,price,aeusd_in_stab_pool,trove_array)

    stateful function
      total_rec_mode_loop: (
          liquidation_totals
        , liquidation_sequence
        , IActivePool
        , IDefaultPool
        , int /*price*/
        , int /*aeusd_in_stab_pool*/
        , list(address) /*trove*/
        ) => liquidation_totals
      total_rec_mode_loop(totals,_,_,_,_,_,[]) = totals
      total_rec_mode_loop(totals,vars,apool,dpool,price,aeusd_in_stab_pool,h::hs) | state.troves[h].status != Active =
        total_rec_mode_loop(totals, vars, apool,dpool,price,aeusd_in_stab_pool,hs)
      total_rec_mode_loop(totals,vars,apool,dpool,price,aeusd_in_stab_pool,h::hs) =

        let vars = vars { icr = get_current_icr(h,price) }
        if(vars.back_to_normal_mode)
          // Skip this trove if ICR is greater than MCR and Stability Pool is empty
          if (vars.icr >= mcr() && vars.remaining_aeusd_in_stab_pool == 0)
            total_rec_mode_loop(totals, vars,apool,dpool,price,aeusd_in_stab_pool,hs)
          else
            let tcr = LiquityMath.compute_cr(vars.entire_system_coll, vars.entire_system_debt, price)

            let single_liquidation = liquidate_recovery_mode( apool, dpool, h, vars.icr
                                                            , vars.remaining_aeusd_in_stab_pool
                                                            , tcr, price )

            // Update aggregate trackers
            let vars = vars {
                remaining_aeusd_in_stab_pool @ t = SafeMath.sub(t ,single_liquidation.debt_to_offset)
              , entire_system_debt @ t  = SafeMath.sub(t,single_liquidation.debt_to_offset)
              , entire_system_coll @ t = SafeMath.sub( SafeMath.sub( SafeMath.sub(
                        t,
                        single_liquidation.coll_to_send_to_sp),
                        single_liquidation.coll_gas_compensation),
                        single_liquidation.coll_surplus )
              }

            // Add liquidation values to their respective running totals
            let totals = add_liquidation_values_to_totals(totals, single_liquidation)
            let vars = vars {
              back_to_normal_mode = !check_potential_recovery_mode(vars.entire_system_coll, vars.entire_system_debt, price)
              }
            total_rec_mode_loop(totals, vars,apool,dpool,price,aeusd_in_stab_pool,hs)
        else
          if (vars.back_to_normal_mode && vars.icr < mcr())
            let single_liquidation = liquidate_normal_mode(apool, dpool, h, vars.remaining_aeusd_in_stab_pool)
            let vars = vars { remaining_aeusd_in_stab_pool @ t = SafeMath.sub(t,single_liquidation.debt_to_offset) }

            // Add liquidation values to their respective running totals
            let totals = add_liquidation_values_to_totals(totals, single_liquidation)
            total_rec_mode_loop(totals, vars,apool,dpool,price,aeusd_in_stab_pool,hs)
          // In Normal Mode skip troves with ICR >= MCR
          else total_rec_mode_loop(totals, vars,apool,dpool,price,aeusd_in_stab_pool,hs)

    stateful function get_totals_from_batch_liquidate_normal_mode (
        active_pool: IActivePool
      , default_pool: IDefaultPool
      , price: int
      , aeusd_in_stab_pool: int
      , trove_array: list(address)
      ): liquidation_totals =
        let vars = init_liquidation_sequence() {
            remaining_aeusd_in_stab_pool = aeusd_in_stab_pool
          }
        let totals = init_liquidation_totals()
        total_normal_mode_loop(totals,vars,active_pool,default_pool,price,aeusd_in_stab_pool,trove_array)

    stateful function
      total_normal_mode_loop: (
          liquidation_totals
        , liquidation_sequence
        , IActivePool
        , IDefaultPool
        , int /*price*/
        , int /*aeusd_in_stab_pool*/
        , list(address) /*trove_array*/
        ) => liquidation_totals
      total_normal_mode_loop(totals,_,_,_,_,_,[]) = totals
      total_normal_mode_loop(totals,vars,active_pool,default_pool,price,aeusd_in_stab_pool,h::hs) =
        let vars = vars { icr = get_current_icr(h, price) }
        let loop = (new_totals,new_vars) =>
              total_normal_mode_loop(new_totals,new_vars,active_pool,default_pool,price,aeusd_in_stab_pool,hs)
        if(vars.icr < mcr())
          let single_liquidation = liquidate_normal_mode(active_pool, default_pool, h, vars.remaining_aeusd_in_stab_pool)
          let vars = vars { remaining_aeusd_in_stab_pool @ t = SafeMath.sub(t,single_liquidation.debt_to_offset) }
          // Add liquidation values to their respective running totals
          let totals = add_liquidation_values_to_totals(totals, single_liquidation)
          loop(totals,vars)
        else
          loop(totals,vars)


    function emitLiquidateEvents(borrower,debt,coll,operation) =
          Chain.event(TroveLiquidated(
              borrower
            , Utils.xsToPayload'(
                [debt, coll]
              , trove_manager_operation_to_str(operation)
              )
            ))
          Chain.event(TroveUpdated(
                borrower
              , 0
              , Utils.xsToPayload'(
                  [0, 0]
                , trove_manager_operation_to_str(operation))
              ) )

    /*
    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,
    * starting from the one with the lowest collateral ratio in the system, and moving upwards
    */
    stateful entrypoint liquidate_troves(n: int) = with_addresses((addresses) =>
        let price = addresses.price_feed.fetch_price()
        let aeusd_in_stab_pool = addresses.stability_pool.get_total_aeusd_deposits()
        let recovery_mode_at_start = check_recovery_mode(price)

        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals
        let get_totals =
          if (recovery_mode_at_start)
            get_totals_from_liquidate_troves_sequence_recovery_mode
          else // if !vars.recoveryModeAtStart
            get_totals_from_liquidate_troves_sequence_normal_mode
        let totals = get_totals(price, aeusd_in_stab_pool, n)

        require(totals.total_debt_in_sequence > 0, "TroveManager: nothing to liquidate")

        // Move liquidated AE and AEUSD to the appropriate pools
        addresses.stability_pool.offset(totals.total_debt_to_offset, totals.total_coll_to_send_to_sp)
        redistribute_debt_and_coll(
            addresses.active_pool
          , addresses.default_pool
          , totals.total_debt_to_redistribute
          , totals.total_coll_to_redistribute
          )

        if (totals.total_coll_surplus > 0)
            addresses.active_pool.send_ae(addresses.coll_surplus_pool.address, totals.total_coll_surplus)

        // Update system snapshots
        update_system_snapshots_exclude_coll_remainder(addresses.active_pool, totals.total_coll_gas_compensation)

        let liquidated_debt = totals.total_debt_in_sequence
        let liquidated_coll = SafeMath.sub(
              SafeMath.sub(totals.total_coll_in_sequence,totals.total_coll_gas_compensation)
            , totals.total_coll_surplus
            )
        Chain.event( Liquidation(
            liquidated_debt
          , liquidated_coll
          , Utils.xsToPayload([totals.total_coll_gas_compensation, totals.total_aeusd_gas_compensation])
          ))

        // Send gas compensation to caller
        send_gas_compensation(
            addresses.active_pool
          , Call.caller
          , totals.total_aeusd_gas_compensation
          , totals.total_coll_gas_compensation
          )
      )

    /*
    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it
    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
    */
    stateful function get_totals_from_liquidate_troves_sequence_recovery_mode (
        price: int
      , aeusd_in_stab_pool: int
      , n: int
      ): liquidation_totals = with_addresses((addresses) =>
        /*LocalVariables_LiquidationSequence memory vars*/
        let single_liquidation = init_liquidation_values()

        let remaining_aeusd_in_stab_pool = aeusd_in_stab_pool
        let back_to_normal_mode = false
        let entire_system_debt = get_entire_system_debt()
        let entire_system_coll = get_entire_system_coll()

        let user = addresses.sorted_troves.get_last()
        let first_user = addresses.sorted_troves.get_first()
        totals_from_liquidate_troves_sequence_recovery_mode_loop(
            init_liquidation_totals()
          , n
          , price
          , entire_system_coll
          , entire_system_debt
          , remaining_aeusd_in_stab_pool
          , back_to_normal_mode
          , user
          , first_user
          , addresses )

        /*for (vars.i = 0 vars.i < _n && vars.user != firstUser vars.i++) {*/
        /*}*/
        abort("Asd")
      )
    stateful function
      totals_from_liquidate_troves_sequence_recovery_mode_loop: (
          liquidation_totals /*acc*/
        , int                /*step*/
        , int                /*price*/
        , int                /*entire_system_coll*/
        , int                /*entire_system_debt*/
        , int                /*remaining_aeusd_in_stab_pool*/
        , bool               /*back_to_normal_mode*/
        , option(address)    /*current user*/
        , option(address)    /*first user*/
        , addresses
        ) => liquidation_totals
      totals_from_liquidate_troves_sequence_recovery_mode_loop(totals, step, _, _, _, _, _, user_opt, first_user_opt, _)
        | step =< 0 || user_opt == None || user_opt == first_user_opt = totals
      totals_from_liquidate_troves_sequence_recovery_mode_loop(
          totals
        , step
        , price
        , entire_system_coll
        , entire_system_debt
        , remaining_aeusd_in_stab_pool
        , back_to_normal_mode
        , user_opt
        , first_user_opt
        , addresses
        ) =
        let user = Option.force(user_opt)
        // we need to cache it, because current user is likely going to be deleted
        let next_user_opt = addresses.sorted_troves.get_prev(user)
        // continuation for the next iteration/user
        let continue = (
            totals
          , entire_system_coll
          , entire_system_debt
          , remaining_aeusd_in_stab_pool ) => totals_from_liquidate_troves_sequence_recovery_mode_loop(
                  totals
                , step - 1
                , price
                , entire_system_coll
                , entire_system_debt
                , remaining_aeusd_in_stab_pool
                , back_to_normal_mode
                , next_user_opt
                , first_user_opt
                , addresses )

        let icr = get_current_icr(user, price)

        if (!back_to_normal_mode)
            // Break the loop if ICR is greater than MCR and Stability Pool is empty
            if (icr >= mcr() && remaining_aeusd_in_stab_pool == 0) totals
            else
              let tcr = LiquityMath.compute_cr(entire_system_coll, entire_system_debt, price)

              let single_liquidation = liquidate_recovery_mode(
                  addresses.active_pool
                , addresses.default_pool
                , user
                , icr
                , remaining_aeusd_in_stab_pool
                , tcr
                , price )

              // Update aggregate trackers
              let remaining_aeusd_in_stab_pool = SafeMath.sub(remaining_aeusd_in_stab_pool,single_liquidation.debt_to_offset)
              let entire_system_debt = SafeMath.sub(entire_system_debt,single_liquidation.debt_to_offset)
              let entire_system_coll = List.foldl( SafeMath.sub
                , entire_system_coll
                ,[ single_liquidation.coll_to_send_to_sp
                 , single_liquidation.coll_gas_compensation
                 , single_liquidation.coll_surplus
                 ] )

              // Add liquidation values to their respective running totals
              let totals = add_liquidation_values_to_totals(totals, single_liquidation)

              let back_to_normal_mode = !check_potential_recovery_mode(entire_system_coll, entire_system_debt, price)

              continue(totals, entire_system_coll, entire_system_debt, remaining_aeusd_in_stab_pool)
        else
          if (back_to_normal_mode && icr < mcr())
            let single_liquidation = liquidate_normal_mode(
                addresses.active_pool
              , addresses.default_pool
              , user
              , remaining_aeusd_in_stab_pool )

            let remaining_aeusd_in_stab_pool = SafeMath.sub(remaining_aeusd_in_stab_pool,single_liquidation.debt_to_offset)

            // Add liquidation values to their respective running totals
            let totals = add_liquidation_values_to_totals(totals, single_liquidation)

            continue(totals, entire_system_coll, entire_system_debt, remaining_aeusd_in_stab_pool)
          else // break if the loop reaches a Trove with ICR >= MCR*/
            totals

    stateful function get_totals_from_liquidate_troves_sequence_normal_mode (
        price: int
      , aeusd_in_stab_pool: int
      , n: int
      ): liquidation_totals = with_addresses((addresses)=>
        totals_from_liquidate_troves_sequence_normal_mode_loop(
            init_liquidation_totals()
          , n
          , price
          , aeusd_in_stab_pool
          , addresses )
      )

    stateful function
      totals_from_liquidate_troves_sequence_normal_mode_loop: (
          liquidation_totals    /*acc*/
        , int                   /*step*/
        , int                   /*price*/
        , int                   /*remaining_aeusd_in_stab_pool*/
        , addresses
        ) => liquidation_totals
      totals_from_liquidate_troves_sequence_normal_mode_loop(totals,step,_,_,_) | step =< 0 = totals
      totals_from_liquidate_troves_sequence_normal_mode_loop(
          totals
        , step
        , price
        , remaining_aeusd_in_stab_pool
        , addresses ) =
        let user_opt = addresses.sorted_troves.get_last()
        switch(user_opt)
          None       => totals
          Some(user) =>
            let icr = get_current_icr(user, price)

            if (icr < mcr())
                let single_liquidation = liquidate_normal_mode(
                    addresses.active_pool
                  , addresses.default_pool
                  , user
                  , remaining_aeusd_in_stab_pool )

                let remaining_aeusd_in_stab_pool = SafeMath.sub(
                    remaining_aeusd_in_stab_pool
                  , single_liquidation.debt_to_offset )

                // Add liquidation values to their respective running totals
                let totals = add_liquidation_values_to_totals(totals, single_liquidation)
                totals_from_liquidate_troves_sequence_normal_mode_loop(
                    totals
                  , step - 1
                  , price
                  , remaining_aeusd_in_stab_pool
                  , addresses )
            else totals // break if the loop reaches a Trove with ICR >= MCR*/

    // Liquidate one trove, in Recovery Mode.
    stateful function
      liquidate_recovery_mode: (
          /*activePool:*/ IActivePool
        , /*defaultPool:*/ IDefaultPool
        , /*borrower:*/ address
        , /*icr:*/ int
        , /*aeusd_in_stab_pool:*/ int
        , /*tcr:*/ int
        , /*price:*/ int
        ) => liquidation_values
      liquidate_recovery_mode(_, _, _, _, _, _, _) | List.length(state.trove_owners) =< 1 = init_liquidation_values()
      liquidate_recovery_mode(
          active_pool, default_pool, borrower, icr, aeusd_in_stab_pool, tcr, price
        ) = with_addresses((addresses) =>
          let emitEvents = (debt,coll) => emitLiquidateEvents(borrower,debt,coll,LiquidateInRecoveryMode)
          let (entire_trove_debt, entire_trove_coll, pending_debt_reward, pending_coll_reward) = get_entire_debt_and_coll(borrower)
          let single_liquidation = init_liquidation_values() {
              entire_trove_debt = entire_trove_debt
            , entire_trove_coll = entire_trove_coll
            , coll_gas_compensation = get_coll_gas_compensation(entire_trove_coll)
            , aeusd_gas_compensation = aeusd_gas_compensation()
            }
          let coll_to_liquidate = SafeMath.sub(single_liquidation.entire_trove_coll,single_liquidation.coll_gas_compensation)
          // If ICR <= 100%, purely redistribute the Trove across all active Troves
          if(icr =< pct_100())
            move_pending_trove_rewards_to_active_pool(active_pool, default_pool, pending_debt_reward, pending_coll_reward)
            remove_stake(borrower)

            let single_liquidation = single_liquidation {
                debt_to_offset = 0
              , coll_to_send_to_sp = 0
              , debt_to_redistribute = single_liquidation.entire_trove_debt
              , coll_to_redistribute = coll_to_liquidate
              }
            close_trove(borrower, ClosedByLiquidation)
            emitEvents( single_liquidation.entire_trove_debt, single_liquidation.entire_trove_coll )
            single_liquidation
          else
            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            if((icr > pct_100()) && (icr < mcr()))
              move_pending_trove_rewards_to_active_pool(active_pool, default_pool, pending_debt_reward, pending_coll_reward)
              remove_stake(borrower)

              let (debt_to_offset, coll_to_send_to_sp, debt_to_redistribute, coll_to_redistribute) =
                get_offset_and_redistribution_vals(single_liquidation.entire_trove_debt, coll_to_liquidate, aeusd_in_stab_pool)
              let single_liquidation = single_liquidation {
                    debt_to_offset = debt_to_offset
                  , coll_to_send_to_sp = coll_to_send_to_sp
                  , debt_to_redistribute = debt_to_redistribute
                  , coll_to_redistribute = coll_to_redistribute
                  }

              close_trove(borrower, ClosedByLiquidation)
              emitEvents(single_liquidation.entire_trove_debt, single_liquidation.entire_trove_coll)
              single_liquidation
            else
              /*
              * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
              * and there is AEUSD in the Stability Pool, only offset, with no redistribution,
              * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
              * The remainder due to the capped rate will be claimable as collateral surplus.
              */
              if ((icr >= mcr()) && (icr < tcr) && (single_liquidation.entire_trove_debt =< aeusd_in_stab_pool))
                move_pending_trove_rewards_to_active_pool(active_pool, default_pool, pending_debt_reward, pending_coll_reward)
                require(aeusd_in_stab_pool != 0,"TroveManager: aeusd_in_stab_pool is 0")

                remove_stake(borrower)
                let single_liquidation = get_capped_offset_vals(
                    single_liquidation.entire_trove_debt
                  , single_liquidation.entire_trove_coll
                  , price
                  )

                close_trove(borrower, ClosedByLiquidation)
                if (single_liquidation.coll_surplus > 0)
                    addresses.coll_surplus_pool.account_surplus(borrower, single_liquidation.coll_surplus)

                emitEvents(single_liquidation.entire_trove_debt, single_liquidation.coll_to_send_to_sp)
                single_liquidation
              else init_liquidation_values()
        )

    // Liquidate one trove, in Normal Mode.
    stateful function liquidate_normal_mode(
        active_pool: IActivePool
      , default_pool: IDefaultPool
      , borrower: address
      , aeusd_in_stab_pool: int
      ): liquidation_values =

        let (entire_trove_debt, entire_trove_coll, pending_debt_reward, pending_coll_reward) = get_entire_debt_and_coll(borrower)

        move_pending_trove_rewards_to_active_pool(active_pool, default_pool, pending_debt_reward, pending_coll_reward)
        remove_stake(borrower)

        let single_liquidation = init_liquidation_values(){
            entire_trove_debt = entire_trove_debt
          , entire_trove_coll = entire_trove_coll
          , coll_gas_compensation = get_coll_gas_compensation(entire_trove_coll)
          , aeusd_gas_compensation = aeusd_gas_compensation()
          }
        let coll_to_liquidate = SafeMath.sub(single_liquidation.entire_trove_coll,single_liquidation.coll_gas_compensation)

        let ( debt_to_offset , coll_to_send_to_sp , debt_to_redistribute , coll_to_redistribute) =
            get_offset_and_redistribution_vals(single_liquidation.entire_trove_debt, coll_to_liquidate, aeusd_in_stab_pool)

        let single_liquidation = single_liquidation {
            debt_to_offset       = debt_to_offset
          , coll_to_send_to_sp   = coll_to_send_to_sp
          , debt_to_redistribute = debt_to_redistribute
          , coll_to_redistribute = coll_to_redistribute
          }

        close_trove(borrower, ClosedByLiquidation)
        emitLiquidateEvents(
            borrower
          , single_liquidation.entire_trove_debt
          , single_liquidation.entire_trove_coll
          , LiquidateInNormalMode )
        single_liquidation

    stateful function
      redistribute_debt_and_coll: (
          /*activePool:*/ IActivePool
        , /*defaultPool:*/ IDefaultPool
        , /*debt:*/ int
        , /*coll:*/ int) => unit
      redistribute_debt_and_coll( _ , _ , 0 , _) = ()
      redistribute_debt_and_coll( active_pool , default_pool , debt , coll) =
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_AE and L_AEUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        let ae_numerator = SafeMath.add(coll * Utils.decimal_precision(),state.last_ae_error_redistribution)
        let aeusd_debt_numerator = SafeMath.add(debt* Utils.decimal_precision(),state.last_aeusd_debt_error_redistribution)

        // Get the per-unit-staked terms
        let total_stakes = state.total_stakes
        let ae_reward_per_unit_staked = SafeMath.div(ae_numerator,total_stakes)
        let aeusd_debt_reward_per_unit_staked = SafeMath.div(aeusd_debt_numerator,total_stakes)

        put( state {
              last_ae_error_redistribution = SafeMath.sub(ae_numerator,ae_reward_per_unit_staked * total_stakes)
            , last_aeusd_debt_error_redistribution =
                SafeMath.sub(aeusd_debt_numerator,aeusd_debt_reward_per_unit_staked * total_stakes)
            // Add per-unit-staked terms to the running totals
            , l_ae @ l = SafeMath.add(l,ae_reward_per_unit_staked)
            , l_aeusd_debt @ l = SafeMath.add(l, aeusd_debt_reward_per_unit_staked)
          })


        Chain.event(LTermsUpdated(state.l_ae, state.l_aeusd_debt))

        // Transfer coll and debt from ActivePool to DefaultPool
        active_pool.decrease_aeusd_debt(debt)
        default_pool.increase_aeusd_debt(debt)
        active_pool.send_ae(default_pool.address, coll)

    function send_gas_compensation(active_pool: IActivePool, liquidator: address, aeusd: int, ae: int) = with_addresses((addresses) =>
        if (aeusd > 0)
          addresses.aeusd_token.return_from_pool(addresses.gas_pool, liquidator, aeusd)

        if (ae > 0)
          active_pool.send_ae(liquidator, ae)
      )

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function move_pending_trove_rewards_to_active_pool(
        active_pool: IActivePool
      , default_pool: IDefaultPool
      , aeusd: int
      , ae: int
      ) =
      default_pool.decrease_aeusd_debt(aeusd)
      active_pool.increase_aeusd_debt(aeusd)
      default_pool.send_ae_to_active_pool(ae)

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total AE gas compensation from the liquidation sequence
    *
    * The AE as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    stateful function update_system_snapshots_exclude_coll_remainder(
        activePool: IActivePool, coll_remainder: int
        ) = with_addresses((addresses) =>
          let active_coll = addresses.active_pool.get_ae()
          let liquidated_coll = addresses.default_pool.get_ae()
          let total_collateral_snapshot = SafeMath.sub(active_coll,coll_remainder + liquidated_coll)
          let total_stakes_snapshot = state.total_stakes
          put (state{
            total_collateral_snapshot = total_collateral_snapshot
            , total_stakes_snapshot = total_stakes_snapshot
            })

          Chain.event(SystemSnapshotsUpdated(total_stakes_snapshot, total_collateral_snapshot))
        )

    // Return the Troves entire debt and coll, including pending rewards from redistributions.
    function get_entire_debt_and_coll(
      borrower: address
      ): (int /*debt*/ * int /*coll*/ * int /*pending_aeusd_debt_reward*/ * int /*pending_ae_reward*/) =

      let pending_aeusd_debt_reward = get_pending_aeusd_debt_reward(borrower)
      let pending_ae_reward = get_pending_ae_reward(borrower)

      let trove = state.troves[borrower]
      let debt = trove.debt +  pending_aeusd_debt_reward
      let coll = trove.coll + pending_ae_reward

      (debt,coll,pending_aeusd_debt_reward,pending_ae_reward)

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    stateful function remove_stake(borrower: address) =
        put(state{
            total_stakes @ ts = SafeMath.sub(ts,state.troves[borrower].stake)
          , troves[ borrower ] @ t = t { stake = 0 }
          })

    stateful function close_trove(borrower: address, closed_status: status) = with_addresses( (addresses) =>
        require(closed_status != NonExistent && closed_status != Active, "TroveManager: invalid status for closing trove")

        let trove_owners_array_length = List.length(state.trove_owners)
        require_more_than_one_trove_in_system(trove_owners_array_length)

        put( state {
            troves[ borrower ] @ t = t {
                status = closed_status
              , coll = 0
              , debt = 0
              }
          , reward_snapshots[ borrower ] @ r = r {
                ae = 0
              , aeusd_debt = 0
              }
          })

        remove_trove_owner(borrower, trove_owners_array_length)
        addresses.sorted_troves.remove(borrower)
      )

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    stateful function remove_trove_owner(borrower: address, trove_owners_array_length: int) =
        let trove_status = state.troves[borrower].status
        // It’s set in caller function `_closeTrove`
        require(trove_status != NonExistent && trove_status != Active, "TroveManager: invalid status for removing trove")

        let index = state.troves[borrower].array_index
        let length = trove_owners_array_length
        let idx_last = SafeMath.sub(length,1)

        require(index =< idx_last,"TroveManager: invald index for removing trove")

        let address_to_move = List.get(idx_last,state.trove_owners)

        put(state{
            trove_owners @ t = List.take(idx_last,List.replace_at(index,address_to_move,t))
          , troves[address_to_move] @ t = t {array_index = index}
          })
        Chain.event(TroveIndexUpdated(address_to_move, index))

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
    * redistributed to active troves.
    */
    function get_offset_and_redistribution_vals (
        debt: int
      , coll: int
      , aeusd_in_stab_pool: int
      ): (int /*debt_to_offset*/ * int /*coll_to_send_to_sp*/ * int /*debt_to_redistribute*/ * int /*coll_to_redistribute*/) =
      if (aeusd_in_stab_pool > 0)
        /*
        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
        * between all active troves.
        *
        *  If the trove's debt is larger than the deposited AEUSD in the Stability Pool:
        *
        *  - Offset an amount of the trove's debt equal to the AEUSD in the Stability Pool
        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt
        *
        */
        let debt_to_offset       = LiquityMath.min(debt, aeusd_in_stab_pool)
        let coll_to_send_to_sp   = SafeMath.div(coll * debt_to_offset,debt)
        let debt_to_redistribute = SafeMath.sub(debt,debt_to_offset)
        let coll_to_redistribute = SafeMath.sub(coll,coll_to_send_to_sp)
        (debt_to_offset , coll_to_send_to_sp , debt_to_redistribute , coll_to_redistribute)
      else (0 , 0 , debt , coll)

    /*
     *  Get its offset coll/debt and AE gas comp, and close the trove.
     */
    function get_capped_offset_vals(
        entire_trove_debt: int
      , entire_trove_coll: int
      , price: int
      ): liquidation_values =
      let capped_coll_portion = SafeMath.div(entire_trove_debt*mcr(),price)
      let coll_gas_compensation = get_coll_gas_compensation(capped_coll_portion)
      {  entire_trove_debt      = entire_trove_debt
       , entire_trove_coll      = entire_trove_coll
       , coll_gas_compensation  = coll_gas_compensation
       , aeusd_gas_compensation = aeusd_gas_compensation()
       , debt_to_offset         = entire_trove_debt
       , coll_to_send_to_sp     = SafeMath.sub(capped_coll_portion,coll_gas_compensation)
       , coll_surplus           = SafeMath.sub(entire_trove_coll,capped_coll_portion)
       , debt_to_redistribute   = 0
       , coll_to_redistribute   = 0
       }

    //------------------------------------------------------------------------------
    // CONSTRAINTS
    //------------------------------------------------------------------------------

    function require_caller_is_borrower_operations() = with_addresses((addresses) =>
        require(
          Call.caller == addresses.borrower_operations.address,
          "TroveManager: Caller is not the BorrowerOperations contract" )
      )

    function null_trove(): trove = {
        debt = 0
      , coll = 0
      , stake = 0
      , status = NonExistent
      , array_index = -1
      }
    function require_trove_is_active(borrower: address) = require(
        Map.lookup_default(borrower,state.troves,null_trove()).status == Active,
        "TroveManager: Trove does not exist or is closed"
      )

    function require_aeusd_balance_covers_redemption(redeemer: address, amount: int) = with_addresses((addresses) =>
        require(
          Option.default(0,addresses.aeusd_token.balance(redeemer)) >= amount,
          "TroveManager: Requested redemption amount must be <= user's AEUSD token balance" )
      )

    function require_more_than_one_trove_in_system(trove_owners_array_length: int) = with_addresses( (addresses) =>
        require(
          trove_owners_array_length > 1 && addresses.sorted_troves.get_size() > 1,
          "TroveManager: Only one trove in the system" )
      )

    function require_amount_greater_than_zero(amount: int) =
        require( amount > 0, "TroveManager: Amount must be greater than zero")

    function require_tcr_over_mcr(price: int) =
        require(get_tcr(price) >= mcr(), "TroveManager: Cannot redeem when TCR < MCR")

    function require_after_bootstrap_period() = with_addresses((addresses) =>
        let system_deployment_time = addresses.lqty_token.get_deployment_start_time()
        require(
          Chain.timestamp >= system_deployment_time + bootstrap_period(),
          "TroveManager: Redemptions are not allowed during bootstrap phase" )
      )

    function require_valid_max_fee_percentage(max_fee_percentage: int) = require(
        max_fee_percentage >= redemption_fee_floor() && max_fee_percentage =< Utils.decimal_precision(),
        "Max fee percentage must be between 0.5% and 100%"
      )

    //------------------------------------------------------------------------------
    // UTILS
    //------------------------------------------------------------------------------

    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.
    function get_current_icr(borrower: address, price: int) =
        let (current_ae, current_aeusd_debt) = get_current_trove_amounts(borrower)
        LiquityMath.compute_cr(current_ae, current_aeusd_debt, price)

    function get_current_trove_amounts(borrower: address): (int* int) =
        let pending_ae_reward = get_pending_ae_reward(borrower)
        let pending_aeusd_debt_reward = get_pending_aeusd_debt_reward(borrower)

        let trove = state.troves[borrower]
        let current_ae = trove.coll + pending_ae_reward
        let current_aeusd_debt = trove.debt + pending_aeusd_debt_reward

        (current_ae, current_aeusd_debt)

    // Get the borrower's pending accumulated AE reward, earned by their stake
    function get_pending_ae_reward(borrower: address): int =
        let snapshot_ae = state.reward_snapshots[borrower].ae
        let reward_per_unit_staked = SafeMath.sub(state.l_ae,snapshot_ae)

        let trove = state.troves[borrower]
        if ( reward_per_unit_staked == 0 || trove.status != Active) 0
        else SafeMath.div(trove.stake * reward_per_unit_staked,Utils.decimal_precision())

    // Get the borrower's pending accumulated AEUSD reward, earned by their stake
    function get_pending_aeusd_debt_reward(borrower: address) =
        let snapshot_aeusd_debt = state.reward_snapshots[borrower].aeusd_debt
        let reward_per_unit_staked = SafeMath.sub(state.l_aeusd_debt,snapshot_aeusd_debt)

        let trove = state.troves[borrower]
        if ( reward_per_unit_staked == 0 || trove.status != Active) 0
        else SafeMath.div(trove.stake * reward_per_unit_staked,Utils.decimal_precision())


    function add_liquidation_values_to_totals(
        old_totals: liquidation_totals
      , single_liquidation: liquidation_values
      ): liquidation_totals /*newTotals*/ =

      // Tally all the values with their respective running totals
      {   total_coll_gas_compensation = old_totals.total_coll_gas_compensation + single_liquidation.coll_gas_compensation
        , total_aeusd_gas_compensation = old_totals.total_aeusd_gas_compensation + single_liquidation.aeusd_gas_compensation
        , total_debt_in_sequence = old_totals.total_debt_in_sequence + single_liquidation.entire_trove_debt
        , total_coll_in_sequence = old_totals.total_coll_in_sequence + single_liquidation.entire_trove_coll
        , total_debt_to_offset = old_totals.total_debt_to_offset + single_liquidation.debt_to_offset
        , total_coll_to_send_to_sp = old_totals.total_coll_to_send_to_sp + single_liquidation.coll_to_send_to_sp
        , total_debt_to_redistribute = old_totals.total_debt_to_redistribute + single_liquidation.debt_to_redistribute
        , total_coll_to_redistribute = old_totals.total_coll_to_redistribute + single_liquidation.coll_to_redistribute
        , total_coll_surplus = old_totals.total_coll_surplus + single_liquidation.coll_surplus
        }

    // Check whether or not the system *would be* in Recovery Mode, given an AE:USD price, and the entire system coll and debt.
    function check_potential_recovery_mode(
        entire_system_coll: int
      , entire_system_debt: int
      , price: int
      ): bool =
        let tcr = LiquityMath.compute_cr(entire_system_coll, entire_system_debt, price)
        tcr < ccr()

    //------------------------------------------------------------------------------
    // EVENTS
    //------------------------------------------------------------------------------

    datatype event
      = BorrowerOperationsAddressChanged(IBorrowerOperations /*newBorrowerOperationsAddress*/)
      | PriceFeedAddressChanged(IPriceFeed /*newPriceFeedAddress*/)
      | AEUSDTokenAddressChanged(IAEUSDToken /*newAEUSDTokenAddress*/)
      | ActivePoolAddressChanged(IActivePool /*activePoolAddress*/)
      | DefaultPoolAddressChanged(IDefaultPool /*defaultPoolAddress*/)
      | StabilityPoolAddressChanged(IStabilityPool /*stabilityPoolAddress*/)
      | GasPoolAddressChanged(address /*gasPoolAddress*/)
      | CollSurplusPoolAddressChanged(ICollSurplusPool /*collSurplusPoolAddress*/)
      | SortedTrovesAddressChanged(ISortedTroves /*sortedTrovesAddress*/)
      | LQTYTokenAddressChanged(ILQTYToken /*lqtyTokenAddress*/)
      | LQTYStakingAddressChanged(ILQTYStaking /*lqtyStakingAddress*/)

      | Liquidation(
            int /*liquidatedDebt*/
          , int /*liquidatedColl*/
          , string
          /*
          , int collGasCompensation
          , int _AEUSDGasCompensation
          */
          )
      | Redemption(
            int /*attemptedAEUSDAmount*/
          , int /*actualAEUSDAmount*/
          , string
          /*
          , int AESent
          , int AEFee
          */
          )
      | TroveUpdated(
            address  /*borrower*/
          , int /*debt*/
          , string
          /*
          , TroveManagerOperation
          , int coll
          , int stake
          */
          )
      | TroveLiquidated(
            address /*borrower*/
          , string
          /*
          , TroveManagerOperation
          , int debt
          , int coll
          */
          )
      | BaseRateUpdated(int /*baseRate*/)
      | LastFeeOpTimeUpdated(int /*lastFeeOpTime*/)
      | TotalStakesUpdated(int /*newTotalStakes*/)
      | SystemSnapshotsUpdated(int /*totalStakesSnapshot*/, int /*totalCollateralSnapshot*/)
      | LTermsUpdated(int /*l_ae*/, int /*L_AEUSDDebt*/)
      | TroveSnapshotsUpdated(int /*l_ae*/, int /*L_AEUSDDebt*/)
      | TroveIndexUpdated(address /*borrower*/, int /*newIndex*/)
//#inject "./dependencies/Ownable.events.aes"

    //------------------------------------------------------------------------------
    // EXTENTIONS
    //------------------------------------------------------------------------------
//#inject "./dependencies/Ownable.functions.aes"
//#inject "./dependencies/LiquityBase.functions.aes"

