@compiler >= 6


include "Option.aes"
include "./interfaces/ITroveManager.aes"
include "./interfaces/IStabilityPool.aes"
include "./interfaces/ICollSurplusPool.aes"
include "./interfaces/IAEUSDToken.aes"
include "./interfaces/ISortedTroves.aes"
include "./interfaces/ILQTYToken.aes"
include "./interfaces/ILQTYStaking.aes"
include "./interfaces/IBorrowerOperations.aes"
include "./dependencies/SafeMath.aes"
include "./dependencies/LiquityMath.aes"
include "./dependencies/Utils.aes"
include "./interfaces/IDefaultPool.aes"
include "./interfaces/IPriceFeed.aes"
include "./interfaces/ITimestampOffsetForDebug.aes"

contract TroveManager =

    //------------------------------------------------------------------------------
    // CONSTANTS
    //------------------------------------------------------------------------------

    entrypoint milliseconds_in_one_minute() = 60000
    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    function minute_decay_factor() = 999037758833783000
    function redemption_fee_floor() = Utils.decimal_precision() / 1000 * 5 // 0.5%
    function max_borrowing_fee() = Utils.decimal_precision() / 100 * 5 // 5%

    // During bootsrap period redemptions are not allowed
    function bootstrap_period() = 1209600  // 14 days

    /*
    * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.
    * Corresponds to (1 / ALPHA) in the white paper.
    */
    function beta() = 2
    //------------------------------------------------------------------------------
    // DATA & STATE
    //------------------------------------------------------------------------------

    record addresses = {
        borrower_operations: IBorrowerOperations
      , stability_pool: IStabilityPool
      , gas_pool: address
      , coll_surplus_pool: ICollSurplusPool
      , aeusd_token: IAEUSDToken
      , lqty_token: ILQTYToken
      , lqty_staking: ILQTYStaking
      , sorted_troves: ISortedTroves
      , default_pool: IDefaultPool
      , active_pool: IActivePool
      , price_feed: IPriceFeed
      }
    record state =  {
        owner: option(address)
      , addresses: option(addresses)
      , base_rate: int
        // The timestamp of the latest fee operation (redemption or new AEUSD issuance)
      , last_fee_operation_time: int
      , troves: map(address,trove)
      , total_stakes: int
      // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
      , total_stakes_snapshot: int
      // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
      , total_collateral_snapshot: int
      /*
      * L_AE and L_AEUSDDebt track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:
      *
      * An AE gain of ( stake * [L_AE - L_AE(0)] )
      * A AEUSDDebt increase  of ( stake * [L_AEUSDDebt - L_AEUSDDebt(0)] )
      *
      * Where L_AE(0) and L_AEUSDDebt(0) are snapshots of L_AE and L_AEUSDDebt for the active Trove taken at the instant the stake was made
      */
      , l_ae: int
      , l_aeusd_debt: int
      // Map addresses with active troves to their RewardSnapshot
      , reward_snapshots:  map (address, reward_snapshot)
      // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
      //TODO: this might be canged with a Set
      , trove_owners: list(address)
      // Error trackers for the trove redistribution calculation
      , last_ae_error_redistribution: int
      , last_aeusd_debt_error_redistribution: int
      // simulate time offset in tests
      //NOTE: don't use this for production deployment
      , timestamp_offset_for_debug: option(ITimestampOffsetForDebug)
      }

    datatype status
      = NonExistent
      | Active
      | ClosedByOwner
      | ClosedByLiquidation
      | ClosedByRedemption

    function
      int_to_status: (int) => status
      int_to_status  (0)   = NonExistent
      int_to_status  (1)   = Active
      int_to_status  (2)   = ClosedByOwner
      int_to_status  (3)   = ClosedByLiquidation
      int_to_status  (4)   = ClosedByRedemption
      int_to_status  (_)   = abort("invalid status value")


    datatype trove_manager_operation
      = ApplyPendingRewards
      | LiquidateInNormalMode
      | LiquidateInRecoveryMode
      | RedeemCollateral

    function
      trove_manager_operation_to_str: (trove_manager_operation) => string
      trove_manager_operation_to_str(ApplyPendingRewards)     = "ApplyPendingRewards"
      trove_manager_operation_to_str(LiquidateInNormalMode)   = "LiquidateInNormalMode"
      trove_manager_operation_to_str(LiquidateInRecoveryMode) = "LiquidateInRecoveryMode"
      trove_manager_operation_to_str(RedeemCollateral)        = "RedeemCollateral"

    // Store the necessary data for a trove
    record trove = {
        debt: int
      , coll: int
      , stake: int
      , status: status
      , array_index: int
      }
    // Object containing the AE and AEUSD snapshots for a given active trove
    record reward_snapshot = {ae: int, aeusd_debt: int}
    function null_reward_snapshot() = {ae = 0, aeusd_debt = 0}

    /*
    * --- Variable container records for liquidations ---
    *
    * These records are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    //TODO: remove if not used at the end of first implementation
    record outer_liquidation_function = {
        price: int
      , aeusd_in_stab_pool: int
      , recovery_mode_at_start: bool
      , liquidated_debt: int
      , liquidated_coll: int
      }
    function init_outer_liquidation_function_var(): outer_liquidation_function = {
        price = 0
      , aeusd_in_stab_pool = 0
      , recovery_mode_at_start = false
      , liquidated_debt = 0
      , liquidated_coll = 0
      }

    record inner_single_liquidate_function = {
        coll_to_liquidate: int
      , pending_debt_reward: int
      , pending_coll_reward: int
      }

    record liquidation_sequence = {
        remaining_aeusd_in_stab_pool: int
      /*, i: int*/
      , icr: int
      /*, user: address*/
      , back_to_normal_mode: bool
      , entire_system_debt: int
      , entire_system_coll: int
      }
    function init_liquidation_sequence() = {
        remaining_aeusd_in_stab_pool = 0
      /*, i = 0*/
      , icr = 0
      /*, user = user*/
      , back_to_normal_mode = false
      , entire_system_debt = 0
      , entire_system_coll = 0
      }

    record liquidation_values = {
        entire_trove_debt: int
      , entire_trove_coll: int
      , coll_gas_compensation: int
      , aeusd_gas_compensation: int
      , debt_to_offset: int
      , coll_to_send_to_sp: int
      , debt_to_redistribute: int
      , coll_to_redistribute: int
      , coll_surplus: int
      }
    function init_liquidation_values() = {
        entire_trove_debt = 0
      , entire_trove_coll = 0
      , coll_gas_compensation = 0
      , aeusd_gas_compensation = 0
      , debt_to_offset = 0
      , coll_to_send_to_sp = 0
      , debt_to_redistribute = 0
      , coll_to_redistribute = 0
      , coll_surplus = 0
      }

    record liquidation_totals = {
        total_coll_in_sequence: int
      , total_debt_in_sequence: int
      , total_coll_gas_compensation: int
      , total_aeusd_gas_compensation: int
      , total_debt_to_offset: int
      , total_coll_to_send_to_sp: int
      , total_debt_to_redistribute: int
      , total_coll_to_redistribute: int
      , total_coll_surplus: int
      }
    function init_liquidation_totals(): liquidation_totals = {
        total_coll_in_sequence = 0
      , total_debt_in_sequence = 0
      , total_coll_gas_compensation = 0
      , total_aeusd_gas_compensation = 0
      , total_debt_to_offset = 0
      , total_coll_to_send_to_sp = 0
      , total_debt_to_redistribute = 0
      , total_coll_to_redistribute = 0
      , total_coll_surplus = 0
      }

    record contracts_cache = {
        active_pool: IActivePool
      , default_pool: IDefaultPool
      , aeusd_token: IAEUSDToken
      , lqty_staking: ILQTYStaking
      , sorted_troves: ISortedTroves
      , coll_surplus_pool: ICollSurplusPool
      , gas_pool_address: address
      }

    /*// --- Variable container records for redemptions ---*/

    record redemption_totals = {
        remaining_aeusd: int
      , total_aeusd_to_redeem: int
      , total_ae_drawn: int
      , ae_fee: int
      , ae_to_send_to_redeemer: int
      , decayed_base_rate: int
      , price: int
      , total_aeusd_supply_at_start: int
      }

    function init_redemption_totals() = {
        remaining_aeusd = 0
      , total_aeusd_to_redeem = 0
      , total_ae_drawn = 0
      , ae_fee = 0
      , ae_to_send_to_redeemer = 0
      , decayed_base_rate = 0
      , price = 0
      , total_aeusd_supply_at_start = 0
      }

    record single_redemption_values = {
        aeusd_lot: int
      , ae_lot: int
      , cancelled_partial: bool
      }

    function init_single_redemption_values(): single_redemption_values = {
        aeusd_lot = 0
      , ae_lot = 0
      , cancelled_partial = false
      }

    //------------------------------------------------------------------------------
    // INIT ENTRYPOINTS
    //------------------------------------------------------------------------------

    entrypoint init() =
      {  owner = Some(Call.caller)
       , addresses = None
       , base_rate = 0
       , last_fee_operation_time = 0
       , troves = {}
       , total_stakes = 0
       , total_stakes_snapshot = 0
       , total_collateral_snapshot = 0
       , l_ae = 0
       , l_aeusd_debt = 0
       , reward_snapshots = {}
       , trove_owners = []
       , last_ae_error_redistribution = 0
       , last_aeusd_debt_error_redistribution = 0
       , timestamp_offset_for_debug = None
       }

    stateful entrypoint set_addresses(addresses: addresses) =
      //requirement
      only_owner()

      put(state{addresses = Some(addresses)})

      Chain.event(BorrowerOperationsAddressChanged(addresses.borrower_operations))
      Chain.event(ActivePoolAddressChanged(addresses.active_pool))
      Chain.event(DefaultPoolAddressChanged(addresses.default_pool))
      Chain.event(StabilityPoolAddressChanged(addresses.stability_pool))
      Chain.event(GasPoolAddressChanged(addresses.gas_pool))
      Chain.event(CollSurplusPoolAddressChanged(addresses.coll_surplus_pool))
      Chain.event(PriceFeedAddressChanged(addresses.price_feed))
      Chain.event(AEUSDTokenAddressChanged(addresses.aeusd_token))
      Chain.event(SortedTrovesAddressChanged(addresses.sorted_troves))
      Chain.event(LQTYTokenAddressChanged(addresses.lqty_token))
      Chain.event(LQTYStakingAddressChanged(addresses.lqty_staking))

      renounce_ownership()

    //------------------------------------------------------------------------------
    // DATA GETTERS
    //------------------------------------------------------------------------------

    entrypoint get_trove_owners_count() = List.length(state.trove_owners)

    entrypoint get_trove_from_trove_owners_array(index: int): option(address) =
      List.nth(index,state.trove_owners)


    //------------------------------------------------------------------------------
    // TROVE LIQUIDATION FUNCTIONS
    //------------------------------------------------------------------------------

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    stateful entrypoint liquidate(borrower: address) =
        require_trove_is_active(borrower)
        batch_liquidate_troves([borrower])

    stateful function batch_liquidate_troves(trove_array: list(address)) = with_addresses((addresses) =>
        require(List.length(trove_array) != 0, "TroveManager: Calldata address array must not be empty")

        let active_pool = addresses.active_pool
        let default_pool = addresses.default_pool
        let stability_pool = addresses.stability_pool

        let price = addresses.price_feed.fetch_price()
        let aeusd_in_stab_pool = stability_pool.get_total_aeusd_deposits()
        let recovery_mode_at_start = check_recovery_mode'(price)

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        let totals =
          if (recovery_mode_at_start)
            get_total_from_batch_liquidate_recovery_mode( active_pool, default_pool, price
                                                        , aeusd_in_stab_pool, trove_array )
          else
            get_totals_from_batch_liquidate_normal_mode(active_pool, default_pool, price
                                                       , aeusd_in_stab_pool, trove_array )

        require(totals.total_debt_in_sequence > 0, "TroveManager: nothing to liquidate")

        // Move liquidated AE and AEUSD to the appropriate pools
        stability_pool.offset(totals.total_debt_to_offset, totals.total_coll_to_send_to_sp)
        redistribute_debt_and_coll(
            active_pool
          , default_pool
          , totals.total_debt_to_redistribute
          , totals.total_coll_to_redistribute
          )
        if (totals.total_coll_surplus > 0)
            active_pool.send_ae(addresses.coll_surplus_pool.address, totals.total_coll_surplus)

        // Update system snapshots
        update_system_snapshots_exclude_coll_remainder(active_pool, totals.total_coll_gas_compensation)

        let liquidated_debt = totals.total_debt_in_sequence
        let liquidated_coll = SafeMath.sub(
            SafeMath.sub(totals.total_coll_in_sequence,totals.total_coll_gas_compensation)
          , totals.total_coll_surplus
          )

        Chain.event( Liquidation(
            liquidated_debt
          , liquidated_coll
          , Utils.xsToPayload([totals.total_coll_gas_compensation, totals.total_aeusd_gas_compensation])
          ))
        // Send gas compensation to caller
        send_gas_compensation(
            active_pool
          , Call.caller
          , totals.total_aeusd_gas_compensation
          , totals.total_coll_gas_compensation
          )
      )

    /*
    * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
    */
    stateful function get_total_from_batch_liquidate_recovery_mode (
        active_pool: IActivePool
      , default_pool: IDefaultPool
      , price: int
      , aeusd_in_stab_pool: int
      , trove_array: list(address)
      ): liquidation_totals =
      let vars = init_liquidation_sequence() {
          remaining_aeusd_in_stab_pool = aeusd_in_stab_pool
        , back_to_normal_mode = false
        , entire_system_debt = get_entire_system_debt()
        , entire_system_coll = get_entire_system_coll()
        }
      let totals = init_liquidation_totals()
      total_rec_mode_loop(totals,vars,active_pool,default_pool,price,aeusd_in_stab_pool,trove_array)

    stateful function
      total_rec_mode_loop: (
          liquidation_totals
        , liquidation_sequence
        , IActivePool
        , IDefaultPool
        , int /*price*/
        , int /*aeusd_in_stab_pool*/
        , list(address) /*trove*/
        ) => liquidation_totals
      total_rec_mode_loop(totals,_,_,_,_,_,[]) = totals
      total_rec_mode_loop(totals,vars,apool,dpool,price,aeusd_in_stab_pool,h::hs) | state.troves[h].status != Active =
        total_rec_mode_loop(totals, vars, apool,dpool,price,aeusd_in_stab_pool,hs)
      total_rec_mode_loop(totals,vars,apool,dpool,price,aeusd_in_stab_pool,h::hs) =

        let vars = vars { icr = get_current_icr(h,price) }
        if(vars.back_to_normal_mode)
          // Skip this trove if ICR is greater than MCR and Stability Pool is empty
          if (vars.icr >= mcr() && vars.remaining_aeusd_in_stab_pool == 0)
            total_rec_mode_loop(totals, vars,apool,dpool,price,aeusd_in_stab_pool,hs)
          else
            let tcr = LiquityMath.compute_cr(vars.entire_system_coll, vars.entire_system_debt, price)

            let single_liquidation = liquidate_recovery_mode( apool, dpool, h, vars.icr
                                                            , vars.remaining_aeusd_in_stab_pool
                                                            , tcr, price )

            // Update aggregate trackers
            let vars = vars {
                remaining_aeusd_in_stab_pool @ t = SafeMath.sub(t ,single_liquidation.debt_to_offset)
              , entire_system_debt @ t  = SafeMath.sub(t,single_liquidation.debt_to_offset)
              , entire_system_coll @ t = SafeMath.sub( SafeMath.sub( SafeMath.sub(
                        t,
                        single_liquidation.coll_to_send_to_sp),
                        single_liquidation.coll_gas_compensation),
                        single_liquidation.coll_surplus )
              }

            // Add liquidation values to their respective running totals
            let totals = add_liquidation_values_to_totals(totals, single_liquidation)
            let vars = vars {
              back_to_normal_mode = !check_potential_recovery_mode(vars.entire_system_coll, vars.entire_system_debt, price)
              }
            total_rec_mode_loop(totals, vars,apool,dpool,price,aeusd_in_stab_pool,hs)
        else
          if (vars.back_to_normal_mode && vars.icr < mcr())
            let single_liquidation = liquidate_normal_mode(apool, dpool, h, vars.remaining_aeusd_in_stab_pool)
            let vars = vars { remaining_aeusd_in_stab_pool @ t = SafeMath.sub(t,single_liquidation.debt_to_offset) }

            // Add liquidation values to their respective running totals
            let totals = add_liquidation_values_to_totals(totals, single_liquidation)
            total_rec_mode_loop(totals, vars,apool,dpool,price,aeusd_in_stab_pool,hs)
          // In Normal Mode skip troves with ICR >= MCR
          else total_rec_mode_loop(totals, vars,apool,dpool,price,aeusd_in_stab_pool,hs)

    stateful function get_totals_from_batch_liquidate_normal_mode (
        active_pool: IActivePool
      , default_pool: IDefaultPool
      , price: int
      , aeusd_in_stab_pool: int
      , trove_array: list(address)
      ): liquidation_totals =
        let vars = init_liquidation_sequence() {
            remaining_aeusd_in_stab_pool = aeusd_in_stab_pool
          }
        let totals = init_liquidation_totals()
        total_normal_mode_loop(totals,vars,active_pool,default_pool,price,aeusd_in_stab_pool,trove_array)

    stateful function
      total_normal_mode_loop: (
          liquidation_totals
        , liquidation_sequence
        , IActivePool
        , IDefaultPool
        , int /*price*/
        , int /*aeusd_in_stab_pool*/
        , list(address) /*trove_array*/
        ) => liquidation_totals
      total_normal_mode_loop(totals,_,_,_,_,_,[]) = totals
      total_normal_mode_loop(totals,vars,active_pool,default_pool,price,aeusd_in_stab_pool,h::hs) =
        let vars = vars { icr = get_current_icr(h, price) }
        let loop = (new_totals,new_vars) =>
              total_normal_mode_loop(new_totals,new_vars,active_pool,default_pool,price,aeusd_in_stab_pool,hs)
        if(vars.icr < mcr())
          let single_liquidation = liquidate_normal_mode(active_pool, default_pool, h, vars.remaining_aeusd_in_stab_pool)
          let vars = vars { remaining_aeusd_in_stab_pool @ t = SafeMath.sub(t,single_liquidation.debt_to_offset) }
          // Add liquidation values to their respective running totals
          let totals = add_liquidation_values_to_totals(totals, single_liquidation)
          loop(totals,vars)
        else
          loop(totals,vars)


    function emitLiquidateEvents(borrower,debt,coll,operation) =
          Chain.event(TroveLiquidated(
              borrower
            , Utils.xsToPayload'(
                [debt, coll]
              , trove_manager_operation_to_str(operation)
              )
            ))
          Chain.event(TroveUpdated(
                borrower
              , 0
              , Utils.xsToPayload'(
                  [0, 0]
                , trove_manager_operation_to_str(operation))
              ) )

    /*
    * Liquidate a sequence of troves. Closes a maximum number of n under-collateralized Troves,
    * starting from the one with the lowest collateral ratio in the system, and moving upwards
    */
    stateful entrypoint liquidate_troves(n: int) = with_addresses((addresses) =>
        let price = addresses.price_feed.fetch_price()
        let aeusd_in_stab_pool = addresses.stability_pool.get_total_aeusd_deposits()
        let recovery_mode_at_start = check_recovery_mode'(price)

        // Perform the appropriate liquidation sequence - tally the values, and obtain their totals
        let get_totals =
          if (recovery_mode_at_start)
            get_totals_from_liquidate_troves_sequence_recovery_mode
          else // if !vars.recoveryModeAtStart
            get_totals_from_liquidate_troves_sequence_normal_mode
        let totals = get_totals(price, aeusd_in_stab_pool, n)

        require(totals.total_debt_in_sequence > 0, "TroveManager: nothing to liquidate")

        // Move liquidated AE and AEUSD to the appropriate pools
        addresses.stability_pool.offset(totals.total_debt_to_offset, totals.total_coll_to_send_to_sp)
        redistribute_debt_and_coll(
            addresses.active_pool
          , addresses.default_pool
          , totals.total_debt_to_redistribute
          , totals.total_coll_to_redistribute
          )

        if (totals.total_coll_surplus > 0)
            addresses.active_pool.send_ae(addresses.coll_surplus_pool.address, totals.total_coll_surplus)

        // Update system snapshots
        update_system_snapshots_exclude_coll_remainder(addresses.active_pool, totals.total_coll_gas_compensation)

        let liquidated_debt = totals.total_debt_in_sequence
        let liquidated_coll = SafeMath.sub(
              SafeMath.sub(totals.total_coll_in_sequence,totals.total_coll_gas_compensation)
            , totals.total_coll_surplus
            )
        Chain.event( Liquidation(
            liquidated_debt
          , liquidated_coll
          , Utils.xsToPayload([totals.total_coll_gas_compensation, totals.total_aeusd_gas_compensation])
          ))

        // Send gas compensation to caller
        send_gas_compensation(
            addresses.active_pool
          , Call.caller
          , totals.total_aeusd_gas_compensation
          , totals.total_coll_gas_compensation
          )
      )

    /*
    * This function is used when the liquidateTroves sequence starts during Recovery Mode. However, it
    * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
    */
    stateful function get_totals_from_liquidate_troves_sequence_recovery_mode (
        price: int
      , aeusd_in_stab_pool: int
      , n: int
      ): liquidation_totals = with_addresses((addresses) =>
        /*LocalVariables_LiquidationSequence memory vars*/
        let single_liquidation = init_liquidation_values()

        let remaining_aeusd_in_stab_pool = aeusd_in_stab_pool
        let back_to_normal_mode = false
        let entire_system_debt = get_entire_system_debt()
        let entire_system_coll = get_entire_system_coll()

        let user = addresses.sorted_troves.get_last()
        let first_user = addresses.sorted_troves.get_first()
        totals_from_liquidate_troves_sequence_recovery_mode_loop(
            init_liquidation_totals()
          , n
          , price
          , entire_system_coll
          , entire_system_debt
          , remaining_aeusd_in_stab_pool
          , back_to_normal_mode
          , user
          , first_user
          , addresses )
      )
    stateful function
      totals_from_liquidate_troves_sequence_recovery_mode_loop: (
          liquidation_totals /*acc*/
        , int                /*step*/
        , int                /*price*/
        , int                /*entire_system_coll*/
        , int                /*entire_system_debt*/
        , int                /*remaining_aeusd_in_stab_pool*/
        , bool               /*back_to_normal_mode*/
        , option(address)    /*current user*/
        , option(address)    /*first user*/
        , addresses
        ) => liquidation_totals
      totals_from_liquidate_troves_sequence_recovery_mode_loop(totals, step, _, _, _, _, _, user_opt, first_user_opt, _)
        | step =< 0 || user_opt == None || user_opt == first_user_opt = totals
      totals_from_liquidate_troves_sequence_recovery_mode_loop(
          totals
        , step
        , price
        , entire_system_coll
        , entire_system_debt
        , remaining_aeusd_in_stab_pool
        , back_to_normal_mode
        , user_opt
        , first_user_opt
        , addresses
        ) =
        let user = Option.force(user_opt)
        // we need to cache it, because current user is likely going to be deleted
        let next_user_opt = addresses.sorted_troves.get_prev(user)
        // continuation for the next iteration/user
        let continue = (
            totals
          , entire_system_coll
          , entire_system_debt
          , remaining_aeusd_in_stab_pool ) => totals_from_liquidate_troves_sequence_recovery_mode_loop(
                  totals
                , step - 1
                , price
                , entire_system_coll
                , entire_system_debt
                , remaining_aeusd_in_stab_pool
                , back_to_normal_mode
                , next_user_opt
                , first_user_opt
                , addresses )

        let icr = get_current_icr(user, price)

        if (!back_to_normal_mode)
            // Break the loop if ICR is greater than MCR and Stability Pool is empty
            if (icr >= mcr() && remaining_aeusd_in_stab_pool == 0) totals
            else
              let tcr = LiquityMath.compute_cr(entire_system_coll, entire_system_debt, price)

              let single_liquidation = liquidate_recovery_mode(
                  addresses.active_pool
                , addresses.default_pool
                , user
                , icr
                , remaining_aeusd_in_stab_pool
                , tcr
                , price )

              // Update aggregate trackers
              let remaining_aeusd_in_stab_pool = SafeMath.sub(remaining_aeusd_in_stab_pool,single_liquidation.debt_to_offset)
              let entire_system_debt = SafeMath.sub(entire_system_debt,single_liquidation.debt_to_offset)
              let entire_system_coll = List.foldl( SafeMath.sub
                , entire_system_coll
                ,[ single_liquidation.coll_to_send_to_sp
                 , single_liquidation.coll_gas_compensation
                 , single_liquidation.coll_surplus
                 ] )

              // Add liquidation values to their respective running totals
              let totals = add_liquidation_values_to_totals(totals, single_liquidation)

              let back_to_normal_mode = !check_potential_recovery_mode(entire_system_coll, entire_system_debt, price)

              continue(totals, entire_system_coll, entire_system_debt, remaining_aeusd_in_stab_pool)
        else
          if (back_to_normal_mode && icr < mcr())
            let single_liquidation = liquidate_normal_mode(
                addresses.active_pool
              , addresses.default_pool
              , user
              , remaining_aeusd_in_stab_pool )

            let remaining_aeusd_in_stab_pool = SafeMath.sub(remaining_aeusd_in_stab_pool,single_liquidation.debt_to_offset)

            // Add liquidation values to their respective running totals
            let totals = add_liquidation_values_to_totals(totals, single_liquidation)

            continue(totals, entire_system_coll, entire_system_debt, remaining_aeusd_in_stab_pool)
          else // break if the loop reaches a Trove with ICR >= MCR*/
            totals

    stateful function get_totals_from_liquidate_troves_sequence_normal_mode (
        price: int
      , aeusd_in_stab_pool: int
      , n: int
      ): liquidation_totals = with_addresses((addresses)=>
        totals_from_liquidate_troves_sequence_normal_mode_loop(
            init_liquidation_totals()
          , n
          , price
          , aeusd_in_stab_pool
          , addresses )
      )

    stateful function
      totals_from_liquidate_troves_sequence_normal_mode_loop: (
          liquidation_totals    /*acc*/
        , int                   /*step*/
        , int                   /*price*/
        , int                   /*remaining_aeusd_in_stab_pool*/
        , addresses
        ) => liquidation_totals
      totals_from_liquidate_troves_sequence_normal_mode_loop(totals,step,_,_,_) | step =< 0 = totals
      totals_from_liquidate_troves_sequence_normal_mode_loop(
          totals
        , step
        , price
        , remaining_aeusd_in_stab_pool
        , addresses ) =
        let user_opt = addresses.sorted_troves.get_last()
        switch(user_opt)
          None       => totals
          Some(user) =>
            let icr = get_current_icr(user, price)

            if (icr < mcr())
                let single_liquidation = liquidate_normal_mode(
                    addresses.active_pool
                  , addresses.default_pool
                  , user
                  , remaining_aeusd_in_stab_pool )

                let remaining_aeusd_in_stab_pool = SafeMath.sub(
                    remaining_aeusd_in_stab_pool
                  , single_liquidation.debt_to_offset )

                // Add liquidation values to their respective running totals
                let totals = add_liquidation_values_to_totals(totals, single_liquidation)
                totals_from_liquidate_troves_sequence_normal_mode_loop(
                    totals
                  , step - 1
                  , price
                  , remaining_aeusd_in_stab_pool
                  , addresses )
            else totals // break if the loop reaches a Trove with ICR >= MCR*/

    // Liquidate one trove, in Recovery Mode.
    stateful function
      liquidate_recovery_mode: (
          /*activePool:*/ IActivePool
        , /*defaultPool:*/ IDefaultPool
        , /*borrower:*/ address
        , /*icr:*/ int
        , /*aeusd_in_stab_pool:*/ int
        , /*tcr:*/ int
        , /*price:*/ int
        ) => liquidation_values
      liquidate_recovery_mode(_, _, _, _, _, _, _) | List.length(state.trove_owners) =< 1 = init_liquidation_values()
      liquidate_recovery_mode(
          active_pool, default_pool, borrower, icr, aeusd_in_stab_pool, tcr, price
        ) = with_addresses((addresses) =>
          let emitEvents = (debt,coll) => emitLiquidateEvents(borrower,debt,coll,LiquidateInRecoveryMode)
          let (entire_trove_debt, entire_trove_coll, pending_debt_reward, pending_coll_reward) = get_entire_debt_and_coll(borrower)
          let single_liquidation = init_liquidation_values() {
              entire_trove_debt = entire_trove_debt
            , entire_trove_coll = entire_trove_coll
            , coll_gas_compensation = get_coll_gas_compensation'(entire_trove_coll)
            , aeusd_gas_compensation = aeusd_gas_compensation'()
            }
          let coll_to_liquidate = SafeMath.sub(single_liquidation.entire_trove_coll,single_liquidation.coll_gas_compensation)
          // If ICR <= 100%, purely redistribute the Trove across all active Troves
          if(icr =< pct_100())
            move_pending_trove_rewards_to_active_pool(active_pool, default_pool, pending_debt_reward, pending_coll_reward)
            remove_stake'(borrower)

            let single_liquidation = single_liquidation {
                debt_to_offset = 0
              , coll_to_send_to_sp = 0
              , debt_to_redistribute = single_liquidation.entire_trove_debt
              , coll_to_redistribute = coll_to_liquidate
              }
            close_trove'(borrower, ClosedByLiquidation)
            emitEvents( single_liquidation.entire_trove_debt, single_liquidation.entire_trove_coll )
            single_liquidation
          else
            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            if((icr > pct_100()) && (icr < mcr()))
              move_pending_trove_rewards_to_active_pool(active_pool, default_pool, pending_debt_reward, pending_coll_reward)
              remove_stake'(borrower)

              let (debt_to_offset, coll_to_send_to_sp, debt_to_redistribute, coll_to_redistribute) =
                get_offset_and_redistribution_vals(single_liquidation.entire_trove_debt, coll_to_liquidate, aeusd_in_stab_pool)
              let single_liquidation = single_liquidation {
                    debt_to_offset = debt_to_offset
                  , coll_to_send_to_sp = coll_to_send_to_sp
                  , debt_to_redistribute = debt_to_redistribute
                  , coll_to_redistribute = coll_to_redistribute
                  }

              close_trove'(borrower, ClosedByLiquidation)
              emitEvents(single_liquidation.entire_trove_debt, single_liquidation.entire_trove_coll)
              single_liquidation
            else
              /*
              * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
              * and there is AEUSD in the Stability Pool, only offset, with no redistribution,
              * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
              * The remainder due to the capped rate will be claimable as collateral surplus.
              */
              if ((icr >= mcr()) && (icr < tcr) && (single_liquidation.entire_trove_debt =< aeusd_in_stab_pool))
                move_pending_trove_rewards_to_active_pool(active_pool, default_pool, pending_debt_reward, pending_coll_reward)
                require(aeusd_in_stab_pool != 0,"TroveManager: aeusd_in_stab_pool is 0")

                remove_stake'(borrower)
                let single_liquidation = get_capped_offset_vals(
                    single_liquidation.entire_trove_debt
                  , single_liquidation.entire_trove_coll
                  , price
                  )

                close_trove'(borrower, ClosedByLiquidation)
                if (single_liquidation.coll_surplus > 0)
                    addresses.coll_surplus_pool.account_surplus(borrower, single_liquidation.coll_surplus)

                emitEvents(single_liquidation.entire_trove_debt, single_liquidation.coll_to_send_to_sp)
                single_liquidation
              else init_liquidation_values()
        )

    // Liquidate one trove, in Normal Mode.
    stateful function liquidate_normal_mode(
        active_pool: IActivePool
      , default_pool: IDefaultPool
      , borrower: address
      , aeusd_in_stab_pool: int
      ): liquidation_values =

        let (entire_trove_debt, entire_trove_coll, pending_debt_reward, pending_coll_reward) = get_entire_debt_and_coll(borrower)

        move_pending_trove_rewards_to_active_pool(active_pool, default_pool, pending_debt_reward, pending_coll_reward)
        remove_stake'(borrower)

        let single_liquidation = init_liquidation_values(){
            entire_trove_debt = entire_trove_debt
          , entire_trove_coll = entire_trove_coll
          , coll_gas_compensation = get_coll_gas_compensation'(entire_trove_coll)
          , aeusd_gas_compensation = aeusd_gas_compensation'()
          }
        let coll_to_liquidate = SafeMath.sub(single_liquidation.entire_trove_coll,single_liquidation.coll_gas_compensation)

        let ( debt_to_offset , coll_to_send_to_sp , debt_to_redistribute , coll_to_redistribute) =
            get_offset_and_redistribution_vals(single_liquidation.entire_trove_debt, coll_to_liquidate, aeusd_in_stab_pool)

        let single_liquidation = single_liquidation {
            debt_to_offset       = debt_to_offset
          , coll_to_send_to_sp   = coll_to_send_to_sp
          , debt_to_redistribute = debt_to_redistribute
          , coll_to_redistribute = coll_to_redistribute
          }

        close_trove'(borrower, ClosedByLiquidation)
        emitLiquidateEvents(
            borrower
          , single_liquidation.entire_trove_debt
          , single_liquidation.entire_trove_coll
          , LiquidateInNormalMode )
        single_liquidation

    stateful function
      redistribute_debt_and_coll: (
          /*activePool:*/ IActivePool
        , /*defaultPool:*/ IDefaultPool
        , /*debt:*/ int
        , /*coll:*/ int) => unit
      redistribute_debt_and_coll( _ , _ , 0 , _) = ()
      redistribute_debt_and_coll( active_pool , default_pool , debt , coll) =
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_AE and L_AEUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        let ae_numerator = SafeMath.add(coll * Utils.decimal_precision(),state.last_ae_error_redistribution)
        let aeusd_debt_numerator = SafeMath.add(debt* Utils.decimal_precision(),state.last_aeusd_debt_error_redistribution)

        // Get the per-unit-staked terms
        let total_stakes = state.total_stakes
        let ae_reward_per_unit_staked = SafeMath.div(ae_numerator,total_stakes)
        let aeusd_debt_reward_per_unit_staked = SafeMath.div(aeusd_debt_numerator,total_stakes)

        put( state {
              last_ae_error_redistribution = SafeMath.sub(ae_numerator,ae_reward_per_unit_staked * total_stakes)
            , last_aeusd_debt_error_redistribution =
                SafeMath.sub(aeusd_debt_numerator,aeusd_debt_reward_per_unit_staked * total_stakes)
            // Add per-unit-staked terms to the running totals
            , l_ae @ l = SafeMath.add(l,ae_reward_per_unit_staked)
            , l_aeusd_debt @ l = SafeMath.add(l, aeusd_debt_reward_per_unit_staked)
          })


        Chain.event(LTermsUpdated(state.l_ae, state.l_aeusd_debt))

        // Transfer coll and debt from ActivePool to DefaultPool
        active_pool.decrease_aeusd_debt(debt)
        default_pool.increase_aeusd_debt(debt)
        active_pool.send_ae(default_pool.address, coll)

    function send_gas_compensation(active_pool: IActivePool, liquidator: address, aeusd: int, ae: int) = with_addresses((addresses) =>
        if (aeusd > 0)
          addresses.aeusd_token.return_from_pool(addresses.gas_pool, liquidator, aeusd)

        if (ae > 0)
          active_pool.send_ae(liquidator, ae)
      )

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function move_pending_trove_rewards_to_active_pool(
        active_pool: IActivePool
      , default_pool: IDefaultPool
      , aeusd: int
      , ae: int
      ) =
      default_pool.decrease_aeusd_debt(aeusd)
      active_pool.increase_aeusd_debt(aeusd)
      default_pool.send_ae_to_active_pool(ae)

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total AE gas compensation from the liquidation sequence
    *
    * The AE as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    stateful function update_system_snapshots_exclude_coll_remainder(
        activePool: IActivePool, coll_remainder: int
        ) = with_addresses((addresses) =>
          let active_coll = addresses.active_pool.get_ae()
          let liquidated_coll = addresses.default_pool.get_ae()
          let total_collateral_snapshot = SafeMath.sub(active_coll,coll_remainder + liquidated_coll)
          let total_stakes_snapshot = state.total_stakes
          put (state{
            total_collateral_snapshot = total_collateral_snapshot
            , total_stakes_snapshot = total_stakes_snapshot
            })

          Chain.event(SystemSnapshotsUpdated(total_stakes_snapshot, total_collateral_snapshot))
        )

    // Return the Troves entire debt and coll, including pending rewards from redistributions.
    function get_entire_debt_and_coll(
      borrower: address
      ): (int /*debt*/ * int /*coll*/ * int /*pending_aeusd_debt_reward*/ * int /*pending_ae_reward*/) =

      let pending_aeusd_debt_reward = get_pending_aeusd_debt_reward(borrower)
      let pending_ae_reward = get_pending_ae_reward(borrower)

      let trove = state.troves[borrower]
      let debt = trove.debt +  pending_aeusd_debt_reward
      let coll = trove.coll + pending_ae_reward

      (debt,coll,pending_aeusd_debt_reward,pending_ae_reward)

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    stateful entrypoint remove_stake(borrower: address) =
        require_caller_is_borrower_operations()
        remove_stake'(borrower)

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    stateful function remove_stake'(borrower: address) =
        put(state{
            total_stakes @ ts = SafeMath.sub(ts,state.troves[borrower].stake)
          , troves[ borrower ] @ t = t { stake = 0 }
          })

    stateful entrypoint close_trove(borrower: address) =
        require_caller_is_borrower_operations()
        close_trove'(borrower, ClosedByOwner)

    stateful function close_trove'(borrower: address, closed_status: status) = with_addresses( (addresses) =>
        require(closed_status != NonExistent && closed_status != Active, "TroveManager: invalid status for closing trove")

        let trove_owners_array_length = List.length(state.trove_owners)
        require_more_than_one_trove_in_system(trove_owners_array_length)

        put( state {
            troves[ borrower ] @ t = t {
                status = closed_status
              , coll = 0
              , debt = 0
              }
          , reward_snapshots[ borrower ] @ r = r {
                ae = 0
              , aeusd_debt = 0
              }
          })

        remove_trove_owner(borrower, trove_owners_array_length)
        addresses.sorted_troves.remove(borrower)
      )

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    stateful entrypoint add_trove_owner_to_array(borrower: address) =
        require_caller_is_borrower_operations()
        add_trove_owner_to_array'(borrower)

    stateful function add_trove_owner_to_array'(borrower: address): int =
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum AEUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 AEUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */

        // Record the index of the new Troveowner on their Trove struct
        // it's not length - 1 because we are going to add a new one
        let index = List.length( state.trove_owners )

        // Push the Troveowner to the array
        put( state {
            trove_owners @ to = to ++ [borrower]
          , troves[borrower] @ t = t { array_index = index }
          })
        index

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    stateful function remove_trove_owner(borrower: address, trove_owners_array_length: int) =
        let trove_status = state.troves[borrower].status
        // It’s set in caller function `_closeTrove`
        require(trove_status != NonExistent && trove_status != Active, "TroveManager: invalid status for removing trove")

        let index = state.troves[borrower].array_index
        let length = trove_owners_array_length
        let idx_last = SafeMath.sub(length,1)

        require(index =< idx_last,"TroveManager: invald index for removing trove")

        let address_to_move = List.get(idx_last,state.trove_owners)

        put(state{
            trove_owners @ t = List.take(idx_last,List.replace_at(index,address_to_move,t))
          , troves[address_to_move] @ t = t {array_index = index}
          })
        Chain.event(TroveIndexUpdated(address_to_move, index))

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
    * redistributed to active troves.
    */
    function get_offset_and_redistribution_vals (
        debt: int
      , coll: int
      , aeusd_in_stab_pool: int
      ): (int /*debt_to_offset*/ * int /*coll_to_send_to_sp*/ * int /*debt_to_redistribute*/ * int /*coll_to_redistribute*/) =
      if (aeusd_in_stab_pool > 0)
        /*
        * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
        * between all active troves.
        *
        *  If the trove's debt is larger than the deposited AEUSD in the Stability Pool:
        *
        *  - Offset an amount of the trove's debt equal to the AEUSD in the Stability Pool
        *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt
        *
        */
        let debt_to_offset       = LiquityMath.min(debt, aeusd_in_stab_pool)
        let coll_to_send_to_sp   = SafeMath.div(coll * debt_to_offset,debt)
        let debt_to_redistribute = SafeMath.sub(debt,debt_to_offset)
        let coll_to_redistribute = SafeMath.sub(coll,coll_to_send_to_sp)
        (debt_to_offset , coll_to_send_to_sp , debt_to_redistribute , coll_to_redistribute)
      else (0 , 0 , debt , coll)

    /*
     *  Get its offset coll/debt and AE gas comp, and close the trove.
     */
    function get_capped_offset_vals(
        entire_trove_debt: int
      , entire_trove_coll: int
      , price: int
      ): liquidation_values =
      let capped_coll_portion = SafeMath.div(entire_trove_debt*mcr(),price)
      let coll_gas_compensation = get_coll_gas_compensation'(capped_coll_portion)
      {  entire_trove_debt      = entire_trove_debt
       , entire_trove_coll      = entire_trove_coll
       , coll_gas_compensation  = coll_gas_compensation
       , aeusd_gas_compensation = aeusd_gas_compensation'()
       , debt_to_offset         = entire_trove_debt
       , coll_to_send_to_sp     = SafeMath.sub(capped_coll_portion,coll_gas_compensation)
       , coll_surplus           = SafeMath.sub(entire_trove_coll,capped_coll_portion)
       , debt_to_redistribute   = 0
       , coll_to_redistribute   = 0
       }

    //------------------------------------------------------------------------------
    // REDEEM FUNCTIONS
    //------------------------------------------------------------------------------

    /* Send _AEUSDamount AEUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining AEUSD amount, which they can attempt
    * to redeem later.
    */
    //TODO: for debugger purposes we can return total, but we have to move redemption_totals in interface
    stateful entrypoint redeem_collateral(
        aeusd_amount: int
      , first_redemption_hint: option(address)
      , upper_partial_redemption_hint: option(address)
      , lower_partial_redemption_hint: option(address)
      , partial_redemption_hint_nicr: int
      , max_iterations: int
      , max_fee_percentage: int
      ) = with_addresses((addresses) =>

        require_valid_max_fee_percentage(max_fee_percentage)
        require_after_bootstrap_period()

        let totals = init_redemption_totals(){
              price = addresses.price_feed.fetch_price()
            , total_aeusd_supply_at_start = get_entire_system_debt()
            , remaining_aeusd = aeusd_amount
          }
        require_tcr_over_mcr(totals.price)
        require_amount_greater_than_zero(aeusd_amount)
        require_aeusd_balance_covers_redemption(Call.caller, aeusd_amount)

        // Confirm redeemer's balance is less than total AEUSD supply
        require(
            Option.default(0,addresses.aeusd_token.balance(Call.caller)) =< totals.total_aeusd_supply_at_start
          , "TroveManager: aeusd_token redemer balance is greater than total_aeusd_supply_at_start" )

        let current_borrower =
          if (is_valid_first_redemption_hint(addresses.sorted_troves, first_redemption_hint, totals.price))
            first_redemption_hint
          else
            // Find the first trove with ICR >= MCR
            first_trove_with_icr_gte_than_mcr(
                addresses.sorted_troves
              , addresses.sorted_troves.get_last()
              , totals.price
              )

        // Loop through the Troves starting from the one with lowest collateral ratio until _amount of AEUSD is exchanged for collateral
        let max_iterations =
          //TODO: this is uint(-1) from solidy -> we should decide a maximum number of iterations
          //taking in consideration also stack overflows (if any)
          if (max_iterations == 0) 115792089237316195423570985008687907853269984665640564039457584007913129639935 //max uint256
          else max_iterations
        let totals = redeem_collateral_loop'(
            totals
          , max_iterations
          , current_borrower
          , upper_partial_redemption_hint
          , lower_partial_redemption_hint
          , partial_redemption_hint_nicr
          , addresses )

        require(totals.total_ae_drawn > 0, "TroveManager: Unable to redeem any amount")

        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.
        // Use the saved total AEUSD supply value, from before it was reduced by the redemption.
        update_base_rate_from_redemption(totals.total_ae_drawn, totals.price, totals.total_aeusd_supply_at_start)

        // Calculate the AE fee
        let totals  = totals { ae_fee = get_redemption_fee(totals.total_ae_drawn) }

        require_user_accepts_fee(totals.ae_fee, totals.total_ae_drawn, max_fee_percentage)

        // Send the AE fee to the LQTY staking contract
        addresses.active_pool.send_ae(addresses.lqty_staking.address, totals.ae_fee)
        addresses.lqty_staking.increase_f_ae(totals.ae_fee)

        let totals = totals { ae_to_send_to_redeemer = SafeMath.sub(totals.total_ae_drawn,totals.ae_fee) }

        Chain.event( Redemption(
            aeusd_amount
          , totals.total_aeusd_to_redeem
          , Utils.xsToPayload([
              totals.total_ae_drawn
            , totals.ae_fee] )))

        // Burn the total AEUSD that is cancelled with debt, and send the redeemed AE to msg.sender
        addresses.aeusd_token.burn(Call.caller, totals.total_aeusd_to_redeem)
        // Update Active Pool AEUSD, and send AE to account
        addresses.active_pool.decrease_aeusd_debt(totals.total_aeusd_to_redeem)
        addresses.active_pool.send_ae(Call.caller, totals.ae_to_send_to_redeemer)
      )

    stateful function
      redeem_collateral_loop': (
          redemption_totals  /*acc*/
        , int                /*step*/
        , option(address)    /*current_borrower*/
        , option(address)    /*upper_partial_redemption_hint*/
        , option(address)    /*lower_partial_redemption_hint*/
        , int                /*partial_redemption_hint_nicr*/
        , addresses          /*addresses*/
        ) => redemption_totals
      redeem_collateral_loop'(totals,0,_,_,_,_,_) = totals
      redeem_collateral_loop'(totals,_,None,_,_,_,_) = totals
      redeem_collateral_loop'(totals,_,_,_,_,_,_) | totals.remaining_aeusd =< 0 = totals
      redeem_collateral_loop'(
          totals
        , step
        , Some(current_borrower)
        , upper_partial_redemption_hint
        , lower_partial_redemption_hint
        , partial_redemption_hint_nicr
        , addresses ) =
        // Save the address of the Trove preceding the current one, before potentially modifying the list
        let next_user_to_check = addresses.sorted_troves.get_prev(current_borrower)

        apply_pending_rewards'(addresses.active_pool, addresses.default_pool, current_borrower)

        let single_redemption = redeem_collateral_from_trove(
            addresses
          , current_borrower
          , totals.remaining_aeusd
          , totals.price
          , upper_partial_redemption_hint
          , lower_partial_redemption_hint
          , partial_redemption_hint_nicr
          )

        if (single_redemption.cancelled_partial)  // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum),
          totals                                  // therefore we could not redeem from the last Trove
        else
          let totals = totals {
              total_aeusd_to_redeem @ t = t + single_redemption.aeusd_lot
            , total_ae_drawn @ t = t + single_redemption.ae_lot
            , remaining_aeusd @ r  = SafeMath.sub(r, single_redemption.aeusd_lot)
            }
          redeem_collateral_loop'(
              totals
            , step - 1
            , next_user_to_check
            , upper_partial_redemption_hint
            , lower_partial_redemption_hint
            , partial_redemption_hint_nicr
            , addresses )

    function
      first_trove_with_icr_gte_than_mcr: (ISortedTroves, option(address),int) => option(address)
      first_trove_with_icr_gte_than_mcr  (_, None,_) = None
      first_trove_with_icr_gte_than_mcr  (_, Some(current_borrower),price)
        | get_current_icr(current_borrower,price) >= mcr() = Some(current_borrower)
      first_trove_with_icr_gte_than_mcr  (sorted_troves, Some(current_borrower),price) =
          //loop towards the previous user
          first_trove_with_icr_gte_than_mcr(
              sorted_troves
            , sorted_troves.get_prev(current_borrower)
            , price )

    function
      is_valid_first_redemption_hint: ( ISortedTroves , option(address) , int ) => bool
      is_valid_first_redemption_hint  ( _, None, _ ) = false
      is_valid_first_redemption_hint  ( sorted_troves, Some(first_redemption_hint), price ) |
        !sorted_troves.contains(first_redemption_hint)
        || get_current_icr(first_redemption_hint, price) < mcr() = false
      is_valid_first_redemption_hint  ( sorted_troves, Some(first_redemption_hint), price ) =
        switch(sorted_troves.get_next(first_redemption_hint))
          None => true
          Some(next_trove) => get_current_icr(next_trove, price) < mcr()

    /*
    * This function has two impacts on the baseRate state variable:
    * 1) decays the baseRate based on time passed since last redemption or AEUSD borrowing operation.
    * then,
    * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply
    */
    stateful function update_base_rate_from_redemption(ae_drawn: int, price: int, total_aeusd_supply: int): int =
      let decayed_base_rate = calc_decayed_base_rate'()

      /* Convert the drawn AE back to AEUSD at face value rate (1 AEUSD:1 USD), in order to get
      * the fraction of total supply that was redeemed at face value. */
      let redeemed_aeusd_fraction = SafeMath.div(ae_drawn*price,total_aeusd_supply)

      let new_base_rate = decayed_base_rate + SafeMath.div(redeemed_aeusd_fraction,beta())
      let new_base_rate = LiquityMath.min(new_base_rate, Utils.decimal_precision()) // cap baseRate at a maximum of 100%
      // Base rate is always non-zero after redemption
      require(new_base_rate > 0,"TroveManager: new_base_rate must be strict positive")

      /*// Update the baseRate state variable*/
      put(state{ base_rate = new_base_rate})
      Chain.event(BaseRateUpdated(new_base_rate))

      update_last_fee_op_time()

      new_base_rate

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    stateful function update_last_fee_op_time() =
        let time_passed = SafeMath.sub(get_timestamp(),state.last_fee_operation_time)

        if (time_passed >= milliseconds_in_one_minute())
            put(state{ last_fee_operation_time = get_timestamp() })
            Chain.event(LastFeeOpTimeUpdated(get_timestamp()))

    function get_redemption_fee(ae_drawn: int): int =
        calc_redemption_fee(get_redemption_rate(), ae_drawn)

    entrypoint get_redemption_fee_with_decay(ae_drawn: int): int =
        calc_redemption_fee(get_redemption_rate_with_decay(), ae_drawn)

    entrypoint get_redemption_rate_with_decay(): int =
        calc_redemption_rate(calc_decayed_base_rate'())

    function calc_redemption_fee(redemption_rate: int, ae_drawn: int): int =
        let redemption_fee = SafeMath.div(redemption_rate*ae_drawn,Utils.decimal_precision())
        require(redemption_fee < ae_drawn, "TroveManager: Fee would eat up all returned collateral")
        redemption_fee

    function get_redemption_rate(): int =
        calc_redemption_rate(state.base_rate)

    function calc_redemption_rate(base_rate: int) = LiquityMath.min(
        redemption_fee_floor() + base_rate,
        Utils.decimal_precision() // cap at a maximum of 100%
        )

    //------------------------------------------------------------------------------
    // OTHER STATEFUL ENTRYPOINTS
    //------------------------------------------------------------------------------

    // Update borrower's snapshots of L_AE and L_AEUSDDebt to reflect the current values
    stateful entrypoint update_trove_reward_snapshots(borrower: address) =
      require_caller_is_borrower_operations()
      update_trove_reward_snapshots'(borrower)

    stateful function update_trove_reward_snapshots'(borrower: address) =
      put(state{ reward_snapshots[ borrower ] @ rs = rs {
            ae = state.l_ae
          , aeusd_debt = state.l_aeusd_debt
        } })
      Chain.event(TroveSnapshotsUpdated( state.l_ae, state.l_aeusd_debt))

    // Updates the baseRate state variable based on time elapsed since the last redemption or LUSD borrowing operation.
    stateful entrypoint decay_base_rate_from_borrowing() =
        require_caller_is_borrower_operations()

        let decayed_base_rate = calc_decayed_base_rate'()
        // The baseRate can decay to 0
        require(decayed_base_rate =< Utils.decimal_precision(),"TroveManager: invalid base_rate value")

        put( state{ base_rate = decayed_base_rate  })
        Chain.event(BaseRateUpdated(decayed_base_rate))

        update_last_fee_op_time()

    // --- Trove property setters, called by BorrowerOperations ---

    stateful entrypoint set_trove_status(borrower: address, num: int) =
        require_caller_is_borrower_operations()
        put(state{ troves[borrower] @ t = t { status = int_to_status(num) } } )

    stateful entrypoint increase_trove_coll(borrower: address, coll_increase: int): int =
        require_caller_is_borrower_operations()
        require(coll_increase >= 0,"TroveManager: coll_increase is negative")
        let new_coll = state.troves[borrower].coll + coll_increase
        put(state{ troves[borrower] @ t = t { coll = new_coll } } )
        new_coll

    stateful entrypoint decrease_trove_coll(borrower:address, coll_decrease: int): int =
        require_caller_is_borrower_operations()
        require(coll_decrease >= 0,"TroveManager: coll_decrease is negative")
        let new_coll = SafeMath.sub(state.troves[borrower].coll,coll_decrease)
        put(state{ troves[borrower] @ t = t { coll = new_coll } } )
        new_coll

    stateful entrypoint increase_trove_debt(borrower: address, debt_increase: int): int =
        require_caller_is_borrower_operations()
        require(debt_increase >= 0,"TroveManager: debt_increase is negative")
        let new_debt = state.troves[borrower].debt + debt_increase
        put(state{ troves[borrower] @ t = t { debt = new_debt } } )
        new_debt

    stateful entrypoint decrease_trove_debt(borrower: address, debt_decrease: int): int =
        require_caller_is_borrower_operations()
        require(debt_decrease >= 0,"TroveManager: debt_decrease is negative")
        let new_debt = SafeMath.sub(state.troves[borrower].debt,debt_decrease)
        put(state{ troves[borrower] @ t = t { debt = new_debt } } )
        new_debt

    //------------------------------------------------------------------------------
    // STATELESS ENTRYPOINTS
    //------------------------------------------------------------------------------

    entrypoint get_tcr(price: int): int = get_tcr'(price)

    entrypoint check_recovery_mode(price: int): bool = check_recovery_mode'(price)

    entrypoint has_pending_rewards(borrower: address): bool =
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if(Map.lookup_default(borrower,state.troves,null_trove()).status != Active)
          false
        else
          Map.lookup_default(borrower,state.reward_snapshots,null_reward_snapshot()).ae < state.l_ae

    entrypoint get_borrowing_fee(aeusd_debt: int): int =
        calc_borrowing_fee'(get_borrowing_rate(), aeusd_debt)

    entrypoint get_borrowing_fee_with_decay(aeusd_debt: int): int =
        calc_borrowing_fee'(get_borrowing_rate_with_decay(), aeusd_debt)

    function calc_borrowing_fee'(borrowing_rate: int, aeusd_debt: int): int =
        SafeMath.div(borrowing_rate * aeusd_debt,Utils.decimal_precision())

    entrypoint get_borrowing_rate(): int =
        calc_borrowing_rate'(state.base_rate)

    entrypoint get_borrowing_rate_with_decay(): int =
        calc_borrowing_rate'(calc_decayed_base_rate'())

    function calc_borrowing_rate'(base_rate: int): int =
        LiquityMath.min(
            borrowing_fee_floor() + base_rate
          , max_borrowing_fee()
          )

    entrypoint get_trove_status(borrower: address): status =
        state.troves[borrower].status

    entrypoint get_trove_stake(borrower: address): int =
        state.troves[borrower].stake

    entrypoint getTroveDebt(borrower: address): int =
        state.troves[borrower].debt

    entrypoint get_trove_coll(borrower: address): int =
        state.troves[borrower].coll

    //------------------------------------------------------------------------------
    // CONSTRAINTS
    //------------------------------------------------------------------------------

    function require_caller_is_borrower_operations() = with_addresses((addresses) =>
        require(
          Call.caller == addresses.borrower_operations.address,
          "TroveManager: Caller is not the BorrowerOperations contract" )
      )

    function null_trove(): trove = {
        debt = 0
      , coll = 0
      , stake = 0
      , status = NonExistent
      , array_index = -1
      }
    function require_trove_is_active(borrower: address) = require(
        Map.lookup_default(borrower,state.troves,null_trove()).status == Active,
        "TroveManager: Trove does not exist or is closed"
      )

    function require_aeusd_balance_covers_redemption(redeemer: address, amount: int) = with_addresses((addresses) =>
        require(
          Option.default(0,addresses.aeusd_token.balance(redeemer)) >= amount,
          "TroveManager: Requested redemption amount must be <= user's AEUSD token balance" )
      )

    function require_more_than_one_trove_in_system(trove_owners_array_length: int) = with_addresses( (addresses) =>
        require(
          trove_owners_array_length > 1 && addresses.sorted_troves.get_size() > 1,
          "TroveManager: Only one trove in the system" )
      )

    function require_amount_greater_than_zero(amount: int) =
        require( amount > 0, "TroveManager: Amount must be greater than zero")

    function require_tcr_over_mcr(price: int) =
        require(get_tcr'(price) >= mcr(), "TroveManager: Cannot redeem when TCR < MCR")

    function require_after_bootstrap_period() = with_addresses((addresses) =>
        let system_deployment_time = addresses.lqty_token.get_deployment_start_time()
        require(
          get_timestamp() >= system_deployment_time + bootstrap_period(),
          "TroveManager: Redemptions are not allowed during bootstrap phase" )
      )

    function require_valid_max_fee_percentage(max_fee_percentage: int) = require(
        max_fee_percentage >= redemption_fee_floor() && max_fee_percentage =< Utils.decimal_precision(),
        "Max fee percentage must be between 0.5% and 100%"
      )

    stateful entrypoint apply_pending_rewards(borrower: address) = with_addresses((addresses) =>
        require_caller_is_borrower_operations()
        apply_pending_rewards'(addresses.active_pool, addresses.default_pool, borrower)
      )

    //------------------------------------------------------------------------------
    // UTILS
    //------------------------------------------------------------------------------

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    stateful function apply_pending_rewards'(active_pool: IActivePool, default_pool: IDefaultPool, borrower: address) =
        if (has_pending_rewards(borrower))
          require_trove_is_active(borrower)
          // Compute pending rewards
          let pending_ae_reward = get_pending_ae_reward(borrower)
          let pending_aeusd_debt_reward = get_pending_aeusd_debt_reward(borrower)

          // Apply pending rewards to trove's state
          put(state{ troves[ borrower ] @ t = t {
                coll @ c = c + pending_ae_reward
              , debt @ d = d + pending_aeusd_debt_reward
            } })

          update_trove_reward_snapshots'(borrower)

          /*// Transfer from DefaultPool to ActivePool*/
          move_pending_trove_rewards_to_active_pool(active_pool, default_pool, pending_aeusd_debt_reward, pending_ae_reward)

          let trove = state.troves[borrower]
          Chain.event(TroveUpdated(
                borrower
              , trove.debt
              , Utils.xsToPayload'(
                  [trove.coll, trove.stake]
                , trove_manager_operation_to_str(ApplyPendingRewards))
              ) )

    // Redeem as much collateral as possible from _borrower's Trove in exchange for AEUSD up to _maxAEUSDamount
    stateful function redeem_collateral_from_trove(
        addresses: addresses
      , borrower: address
      , max_aeusd_amount: int
      , price: int
      , upper_partial_redemption_hint: option(address)
      , lower_partial_redemption_hint: option(address)
      , partial_redemption_hint_nicr: int
      ): single_redemption_values =
      let trove = state.troves[borrower]
      let aeusd_lot = LiquityMath.min( max_aeusd_amount, SafeMath.sub(trove.debt,aeusd_gas_compensation'()))
      let single_redemption = init_single_redemption_values(){
          // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve
          aeusd_lot = aeusd_lot
          // Get the AELot of equivalent value in USD
        , ae_lot = SafeMath.div(aeusd_lot * Utils.decimal_precision(),price)
        }
      // Decrease the debt and collateral of the current Trove according to the AEUSD lot and corresponding AE to send
      let new_debt = SafeMath.sub(trove.debt,single_redemption.aeusd_lot)
      let new_coll = SafeMath.sub(trove.coll,single_redemption.ae_lot)

      if (new_debt == aeusd_gas_compensation'())
          // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed
          remove_stake'(borrower)
          close_trove'(borrower, ClosedByRedemption)
          redeem_close_trove(addresses, borrower, new_debt, new_coll)
          Chain.event(TroveUpdated(
                borrower
              , 0
              , Utils.xsToPayload'(
                  [0, 0]
                , trove_manager_operation_to_str(RedeemCollateral))
              ) )
          single_redemption
      else
          let new_nicr = LiquityMath.compute_nominal_cr(new_coll, new_debt)

          /*
          * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost
          * certainly result in running out of gas.
          *
          * If the resultant net debt of the partial is less than the minimum, net debt we bail.
          */
          if (new_nicr != partial_redemption_hint_nicr || get_net_debt(new_debt) < min_net_debt())
            single_redemption {cancelled_partial = true}
          else
            addresses.sorted_troves.re_insert(
                borrower
              , new_nicr
              , upper_partial_redemption_hint
              , lower_partial_redemption_hint )

            put( state { troves[borrower] @ t = t { debt = new_debt, coll = new_coll } })
            update_stake_and_total_stakes'(borrower)

            Chain.event(TroveUpdated(
                  borrower
                , new_debt
                , Utils.xsToPayload'(
                    [new_coll, state.troves[borrower].stake]
                  , trove_manager_operation_to_str(RedeemCollateral))
                ) )
            single_redemption

    stateful entrypoint update_stake_and_total_stakes(borrower: address) =
        require_caller_is_borrower_operations()
        update_stake_and_total_stakes'(borrower)

    // Update borrower's stake based on their latest collateral value
    stateful function update_stake_and_total_stakes'(borrower: address): int =
        let trove = state.troves[borrower]
        let new_stake = compute_new_stake(trove.coll)
        let old_stake = trove.stake

        put(state{
            troves[borrower] @ t = t { stake = new_stake }
          , total_stakes @ t = SafeMath.sub(t,old_stake) + new_stake
          })
        Chain.event(TotalStakesUpdated(state.total_stakes))

        new_stake

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function compute_new_stake(coll: int): int =
        let total_collateral_snapshot = state.total_collateral_snapshot
        if (total_collateral_snapshot == 0) coll
        else
          /*
          * The following assert() holds true because:
          * - The system always contains >= 1 trove
          * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
          * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
          */
          let total_stakes_snapshot = state.total_stakes_snapshot
          require( total_stakes_snapshot> 0,"TroveManager: total_stakes_snapshot should strict positive")
          SafeMath.div(coll * total_stakes_snapshot,total_collateral_snapshot)

    /*
    * Called when a full redemption occurs, and closes the trove.
    * The redeemer swaps (debt - liquidation reserve) AEUSD for (debt - liquidation reserve) worth of AE, so the AEUSD liquidation reserve left corresponds to the remaining debt.
    * In order to close the trove, the AEUSD liquidation reserve is burned, and the corresponding debt is removed from the active pool.
    * The debt recorded on the trove's struct is zero'd elswhere, in _closeTrove.
    * Any surplus AE left in the trove, is sent to the Coll surplus pool, and can be later claimed by the borrower.
    */
    stateful function redeem_close_trove(addresses: addresses,borrower: address, aeusd: int, ae: int) =
        addresses.aeusd_token.burn(addresses.gas_pool, aeusd)
        // Update Active Pool AEUSD, and send AE to account
        addresses.active_pool.decrease_aeusd_debt(aeusd)

        // send AE from Active Pool to CollSurplus Pool
        addresses.coll_surplus_pool.account_surplus(borrower, ae)
        addresses.active_pool.send_ae(addresses.coll_surplus_pool.address, ae)

    function calc_decayed_base_rate'(): int =
        let minutes_passed = minutes_passed_since_last_fee_op'()
        let decay_factor = LiquityMath.dec_pow(minute_decay_factor(), minutes_passed)

        SafeMath.div(state.base_rate * decay_factor,Utils.decimal_precision())

    function minutes_passed_since_last_fee_op'(): int =
        SafeMath.div(
          SafeMath.sub(get_timestamp(),state.last_fee_operation_time),
          milliseconds_in_one_minute() )

    // Return the current collateral ratio (ICR) of a given Trove. Takes a trove's pending coll and debt rewards from redistributions into account.
    function get_current_icr(borrower: address, price: int) =
        let (current_ae, current_aeusd_debt) = get_current_trove_amounts(borrower)
        LiquityMath.compute_cr(current_ae, current_aeusd_debt, price)

    function get_current_trove_amounts(borrower: address): (int* int) =
        let pending_ae_reward = get_pending_ae_reward(borrower)
        let pending_aeusd_debt_reward = get_pending_aeusd_debt_reward(borrower)

        let trove = state.troves[borrower]
        let current_ae = trove.coll + pending_ae_reward
        let current_aeusd_debt = trove.debt + pending_aeusd_debt_reward

        (current_ae, current_aeusd_debt)

    // Get the borrower's pending accumulated AE reward, earned by their stake
    function get_pending_ae_reward(borrower: address): int =
        let snapshot_ae = state.reward_snapshots[borrower].ae
        let reward_per_unit_staked = SafeMath.sub(state.l_ae,snapshot_ae)

        let trove = state.troves[borrower]
        if ( reward_per_unit_staked == 0 || trove.status != Active) 0
        else SafeMath.div(trove.stake * reward_per_unit_staked,Utils.decimal_precision())

    // Get the borrower's pending accumulated AEUSD reward, earned by their stake
    function get_pending_aeusd_debt_reward(borrower: address) =
        let snapshot_aeusd_debt = state.reward_snapshots[borrower].aeusd_debt
        let reward_per_unit_staked = SafeMath.sub(state.l_aeusd_debt,snapshot_aeusd_debt)

        let trove = state.troves[borrower]
        if ( reward_per_unit_staked == 0 || trove.status != Active) 0
        else SafeMath.div(trove.stake * reward_per_unit_staked,Utils.decimal_precision())


    function add_liquidation_values_to_totals(
        old_totals: liquidation_totals
      , single_liquidation: liquidation_values
      ): liquidation_totals /*newTotals*/ =

      // Tally all the values with their respective running totals
      {   total_coll_gas_compensation = old_totals.total_coll_gas_compensation + single_liquidation.coll_gas_compensation
        , total_aeusd_gas_compensation = old_totals.total_aeusd_gas_compensation + single_liquidation.aeusd_gas_compensation
        , total_debt_in_sequence = old_totals.total_debt_in_sequence + single_liquidation.entire_trove_debt
        , total_coll_in_sequence = old_totals.total_coll_in_sequence + single_liquidation.entire_trove_coll
        , total_debt_to_offset = old_totals.total_debt_to_offset + single_liquidation.debt_to_offset
        , total_coll_to_send_to_sp = old_totals.total_coll_to_send_to_sp + single_liquidation.coll_to_send_to_sp
        , total_debt_to_redistribute = old_totals.total_debt_to_redistribute + single_liquidation.debt_to_redistribute
        , total_coll_to_redistribute = old_totals.total_coll_to_redistribute + single_liquidation.coll_to_redistribute
        , total_coll_surplus = old_totals.total_coll_surplus + single_liquidation.coll_surplus
        }

    // Check whether or not the system *would be* in Recovery Mode, given an AE:USD price, and the entire system coll and debt.
    function check_potential_recovery_mode(
        entire_system_coll: int
      , entire_system_debt: int
      , price: int
      ): bool =
        let tcr = LiquityMath.compute_cr(entire_system_coll, entire_system_debt, price)
        tcr < ccr()

    //------------------------------------------------------------------------------
    // EVENTS
    //------------------------------------------------------------------------------

    datatype event
      = BorrowerOperationsAddressChanged(IBorrowerOperations /*newBorrowerOperationsAddress*/)
      | PriceFeedAddressChanged(IPriceFeed /*newPriceFeedAddress*/)
      | AEUSDTokenAddressChanged(IAEUSDToken /*newAEUSDTokenAddress*/)
      | ActivePoolAddressChanged(IActivePool /*activePoolAddress*/)
      | DefaultPoolAddressChanged(IDefaultPool /*defaultPoolAddress*/)
      | StabilityPoolAddressChanged(IStabilityPool /*stabilityPoolAddress*/)
      | GasPoolAddressChanged(address /*gasPoolAddress*/)
      | CollSurplusPoolAddressChanged(ICollSurplusPool /*collSurplusPoolAddress*/)
      | SortedTrovesAddressChanged(ISortedTroves /*sortedTrovesAddress*/)
      | LQTYTokenAddressChanged(ILQTYToken /*lqtyTokenAddress*/)
      | LQTYStakingAddressChanged(ILQTYStaking /*lqtyStakingAddress*/)

      | Liquidation(
            int /*liquidatedDebt*/
          , int /*liquidatedColl*/
          , string
          /*
          , int collGasCompensation
          , int _AEUSDGasCompensation
          */
          )
      | Redemption(
            int /*attemptedAEUSDAmount*/
          , int /*actualAEUSDAmount*/
          , string
          /*
          , int AESent
          , int AEFee
          */
          )
      | TroveUpdated(
            address  /*borrower*/
          , int /*debt*/
          , string
          /*
          , TroveManagerOperation
          , int coll
          , int stake
          */
          )
      | TroveLiquidated(
            address /*borrower*/
          , string
          /*
          , TroveManagerOperation
          , int debt
          , int coll
          */
          )
      | BaseRateUpdated(int /*baseRate*/)
      | LastFeeOpTimeUpdated(int /*lastFeeOpTime*/)
      | TotalStakesUpdated(int /*newTotalStakes*/)
      | SystemSnapshotsUpdated(int /*totalStakesSnapshot*/, int /*totalCollateralSnapshot*/)
      | LTermsUpdated(int /*l_ae*/, int /*L_AEUSDDebt*/)
      | TroveSnapshotsUpdated(int /*l_ae*/, int /*L_AEUSDDebt*/)
      | TroveIndexUpdated(address /*borrower*/, int /*newIndex*/)
//#inject "./dependencies/Ownable.events.aes"

    //------------------------------------------------------------------------------
    // EXTENTIONS
    //------------------------------------------------------------------------------
//#inject "./dependencies/Ownable.functions.aes"
//#inject "./dependencies/LiquityBase.functions.aes"
//#inject "./dependencies/Timestamp.function.aes"

//This should be available just for debug/tests
//#inject-debug "../test/contracts/TroveManager.tester.aes"
//#inject-debug "../test/contracts/TimestampOffsetSetter.tester.aes"

